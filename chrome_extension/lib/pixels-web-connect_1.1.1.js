/*! For license information please see index.js.LICENSE.txt */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.pixelsWebConnect = e() : t.pixelsWebConnect = e() }(this, (() => (() => { var t = { 699: t => { "use strict"; var e, n = "object" == typeof Reflect ? Reflect : null, r = n && "function" == typeof n.apply ? n.apply : function (t, e, n) { return Function.prototype.apply.call(t, e, n) }; e = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : function (t) { return Object.getOwnPropertyNames(t) }; var i = Number.isNaN || function (t) { return t != t }; function o() { o.init.call(this) } t.exports = o, t.exports.once = function (t, e) { return new Promise((function (n, r) { function i(n) { t.removeListener(e, o), r(n) } function o() { "function" == typeof t.removeListener && t.removeListener("error", i), n([].slice.call(arguments)) } y(t, e, o, { once: !0 }), "error" !== e && function (t, e, n) { "function" == typeof t.on && y(t, "error", e, { once: !0 }) }(t, i) })) }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0; var s = 10; function a(t) { if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t) } function c(t) { return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners } function u(t, e, n, r) { var i, o, s, u; if (a(n), void 0 === (o = t._events) ? (o = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== o.newListener && (t.emit("newListener", e, n.listener ? n.listener : n), o = t._events), s = o[e]), void 0 === s) s = o[e] = n, ++t._eventsCount; else if ("function" == typeof s ? s = o[e] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), (i = c(t)) > 0 && s.length > i && !s.warned) { s.warned = !0; var l = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit"); l.name = "MaxListenersExceededWarning", l.emitter = t, l.type = e, l.count = s.length, u = l, console && console.warn && console.warn(u) } return t } function l() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function f(t, e, n) { var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, i = l.bind(r); return i.listener = n, r.wrapFn = i, i } function p(t, e, n) { var r = t._events; if (void 0 === r) return []; var i = r[e]; return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function (t) { for (var e = new Array(t.length), n = 0; n < e.length; ++n)e[n] = t[n].listener || t[n]; return e }(i) : d(i, i.length) } function h(t) { var e = this._events; if (void 0 !== e) { var n = e[t]; if ("function" == typeof n) return 1; if (void 0 !== n) return n.length } return 0 } function d(t, e) { for (var n = new Array(e), r = 0; r < e; ++r)n[r] = t[r]; return n } function y(t, e, n, r) { if ("function" == typeof t.on) r.once ? t.once(e, n) : t.on(e, n); else { if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t); t.addEventListener(e, (function i(o) { r.once && t.removeEventListener(e, i), n(o) })) } } Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function () { return s }, set: function (t) { if ("number" != typeof t || t < 0 || i(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + "."); s = t } }), o.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, o.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || i(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }, o.prototype.getMaxListeners = function () { return c(this) }, o.prototype.emit = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e.push(arguments[n]); var i = "error" === t, o = this._events; if (void 0 !== o) i = i && void 0 === o.error; else if (!i) return !1; if (i) { var s; if (e.length > 0 && (s = e[0]), s instanceof Error) throw s; var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : "")); throw a.context = s, a } var c = o[t]; if (void 0 === c) return !1; if ("function" == typeof c) r(c, this, e); else { var u = c.length, l = d(c, u); for (n = 0; n < u; ++n)r(l[n], this, e) } return !0 }, o.prototype.addListener = function (t, e) { return u(this, t, e, !1) }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (t, e) { return u(this, t, e, !0) }, o.prototype.once = function (t, e) { return a(e), this.on(t, f(this, t, e)), this }, o.prototype.prependOnceListener = function (t, e) { return a(e), this.prependListener(t, f(this, t, e)), this }, o.prototype.removeListener = function (t, e) { var n, r, i, o, s; if (a(e), void 0 === (r = this._events)) return this; if (void 0 === (n = r[t])) return this; if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, n.listener || e)); else if ("function" != typeof n) { for (i = -1, o = n.length - 1; o >= 0; o--)if (n[o] === e || n[o].listener === e) { s = n[o].listener, i = o; break } if (i < 0) return this; 0 === i ? n.shift() : function (t, e) { for (; e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop() }(n, i), 1 === n.length && (r[t] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", t, s || e) } return this }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (t) { var e, n, r; if (void 0 === (n = this._events)) return this; if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this; if (0 === arguments.length) { var i, o = Object.keys(n); for (r = 0; r < o.length; ++r)"removeListener" !== (i = o[r]) && this.removeAllListeners(i); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (e = n[t])) this.removeListener(t, e); else if (void 0 !== e) for (r = e.length - 1; r >= 0; r--)this.removeListener(t, e[r]); return this }, o.prototype.listeners = function (t) { return p(this, t, !0) }, o.prototype.rawListeners = function (t) { return p(this, t, !1) }, o.listenerCount = function (t, e) { return "function" == typeof t.listenerCount ? t.listenerCount(e) : h.call(t, e) }, o.prototype.listenerCount = h, o.prototype.eventNames = function () { return this._eventsCount > 0 ? e(this._events) : [] } }, 738: (t, e, n) => { var r; !function (t) { !function (e) { var r = "object" == typeof n.g ? n.g : "object" == typeof self ? self : "object" == typeof this ? this : Function("return this;")(), i = o(t); function o(t, e) { return function (n, r) { "function" != typeof t[n] && Object.defineProperty(t, n, { configurable: !0, writable: !0, value: r }), e && e(n, r) } } void 0 === r.Reflect ? r.Reflect = t : i = o(r.Reflect, i), function (t) { var e = Object.prototype.hasOwnProperty, n = "function" == typeof Symbol, r = n && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", i = n && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", o = "function" == typeof Object.create, s = { __proto__: [] } instanceof Array, a = !o && !s, c = { create: o ? function () { return G(Object.create(null)) } : s ? function () { return G({ __proto__: null }) } : function () { return G({}) }, has: a ? function (t, n) { return e.call(t, n) } : function (t, e) { return e in t }, get: a ? function (t, n) { return e.call(t, n) ? t[n] : void 0 } : function (t, e) { return t[e] } }, u = Object.getPrototypeOf(Function), l = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, f = l || "function" != typeof Map || "function" != typeof Map.prototype.entries ? function () { var t = {}, e = [], n = function () { function t(t, e, n) { this._index = 0, this._keys = t, this._values = e, this._selector = n } return t.prototype["@@iterator"] = function () { return this }, t.prototype[i] = function () { return this }, t.prototype.next = function () { var t = this._index; if (t >= 0 && t < this._keys.length) { var n = this._selector(this._keys[t], this._values[t]); return t + 1 >= this._keys.length ? (this._index = -1, this._keys = e, this._values = e) : this._index++, { value: n, done: !1 } } return { value: void 0, done: !0 } }, t.prototype.throw = function (t) { throw this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), t }, t.prototype.return = function (t) { return this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), { value: t, done: !0 } }, t }(); return function () { function e() { this._keys = [], this._values = [], this._cacheKey = t, this._cacheIndex = -2 } return Object.defineProperty(e.prototype, "size", { get: function () { return this._keys.length }, enumerable: !0, configurable: !0 }), e.prototype.has = function (t) { return this._find(t, !1) >= 0 }, e.prototype.get = function (t) { var e = this._find(t, !1); return e >= 0 ? this._values[e] : void 0 }, e.prototype.set = function (t, e) { var n = this._find(t, !0); return this._values[n] = e, this }, e.prototype.delete = function (e) { var n = this._find(e, !1); if (n >= 0) { for (var r = this._keys.length, i = n + 1; i < r; i++)this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i]; return this._keys.length--, this._values.length--, e === this._cacheKey && (this._cacheKey = t, this._cacheIndex = -2), !0 } return !1 }, e.prototype.clear = function () { this._keys.length = 0, this._values.length = 0, this._cacheKey = t, this._cacheIndex = -2 }, e.prototype.keys = function () { return new n(this._keys, this._values, r) }, e.prototype.values = function () { return new n(this._keys, this._values, o) }, e.prototype.entries = function () { return new n(this._keys, this._values, s) }, e.prototype["@@iterator"] = function () { return this.entries() }, e.prototype[i] = function () { return this.entries() }, e.prototype._find = function (t, e) { return this._cacheKey !== t && (this._cacheIndex = this._keys.indexOf(this._cacheKey = t)), this._cacheIndex < 0 && e && (this._cacheIndex = this._keys.length, this._keys.push(t), this._values.push(void 0)), this._cacheIndex }, e }(); function r(t, e) { return t } function o(t, e) { return e } function s(t, e) { return [t, e] } }() : Map, p = l || "function" != typeof Set || "function" != typeof Set.prototype.entries ? function () { function t() { this._map = new f } return Object.defineProperty(t.prototype, "size", { get: function () { return this._map.size }, enumerable: !0, configurable: !0 }), t.prototype.has = function (t) { return this._map.has(t) }, t.prototype.add = function (t) { return this._map.set(t, t), this }, t.prototype.delete = function (t) { return this._map.delete(t) }, t.prototype.clear = function () { this._map.clear() }, t.prototype.keys = function () { return this._map.keys() }, t.prototype.values = function () { return this._map.values() }, t.prototype.entries = function () { return this._map.entries() }, t.prototype["@@iterator"] = function () { return this.keys() }, t.prototype[i] = function () { return this.keys() }, t }() : Set, h = new (l || "function" != typeof WeakMap ? function () { var t = 16, n = c.create(), r = i(); return function () { function t() { this._key = i() } return t.prototype.has = function (t) { var e = o(t, !1); return void 0 !== e && c.has(e, this._key) }, t.prototype.get = function (t) { var e = o(t, !1); return void 0 !== e ? c.get(e, this._key) : void 0 }, t.prototype.set = function (t, e) { return o(t, !0)[this._key] = e, this }, t.prototype.delete = function (t) { var e = o(t, !1); return void 0 !== e && delete e[this._key] }, t.prototype.clear = function () { this._key = i() }, t }(); function i() { var t; do { t = "@@WeakMap@@" + a() } while (c.has(n, t)); return n[t] = !0, t } function o(t, n) { if (!e.call(t, r)) { if (!n) return; Object.defineProperty(t, r, { value: c.create() }) } return t[r] } function s(t, e) { for (var n = 0; n < e; ++n)t[n] = 255 * Math.random() | 0; return t } function a() { var e, n = (e = t, "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(e)) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(new Uint8Array(e)) : s(new Uint8Array(e), e) : s(new Array(e), e)); n[6] = 79 & n[6] | 64, n[8] = 191 & n[8] | 128; for (var r = "", i = 0; i < t; ++i) { var o = n[i]; 4 !== i && 6 !== i && 8 !== i || (r += "-"), o < 16 && (r += "0"), r += o.toString(16).toLowerCase() } return r } }() : WeakMap); function d(t, e, n) { var r = h.get(t); if (B(r)) { if (!n) return; r = new f, h.set(t, r) } var i = r.get(e); if (B(i)) { if (!n) return; i = new f, r.set(e, i) } return i } function y(t, e, n) { if (g(t, e, n)) return !0; var r = F(e); return !C(r) && y(t, r, n) } function g(t, e, n) { var r = d(e, n, !1); return !B(r) && !!r.has(t) } function m(t, e, n) { if (g(t, e, n)) return v(t, e, n); var r = F(e); return C(r) ? void 0 : m(t, r, n) } function v(t, e, n) { var r = d(e, n, !1); if (!B(r)) return r.get(t) } function b(t, e, n, r) { d(n, r, !0).set(t, e) } function w(t, e) { var n = _(t, e), r = F(t); if (null === r) return n; var i = w(r, e); if (i.length <= 0) return n; if (n.length <= 0) return i; for (var o = new p, s = [], a = 0, c = n; a < c.length; a++) { var u = c[a]; o.has(u) || (o.add(u), s.push(u)) } for (var l = 0, f = i; l < f.length; l++)u = f[l], o.has(u) || (o.add(u), s.push(u)); return s } function _(t, e) { var n = [], r = d(t, e, !1); if (B(r)) return n; for (var o = function (t) { var e = E(t, i); if (!x(e)) throw new TypeError; var n = e.call(t); if (!P(n)) throw new TypeError; return n }(r.keys()), s = 0; ;) { var a = R(o); if (!a) return n.length = s, n; var c = a.value; try { n[s] = c } catch (t) { try { M(o) } finally { throw t } } s++ } } function k(t) { if (null === t) return 1; switch (typeof t) { case "undefined": return 0; case "boolean": return 2; case "string": return 3; case "symbol": return 4; case "number": return 5; case "object": return null === t ? 1 : 6; default: return 6 } } function B(t) { return void 0 === t } function C(t) { return null === t } function P(t) { return "object" == typeof t ? null !== t : "function" == typeof t } function A(t, e) { switch (k(t)) { case 0: case 1: case 2: case 3: case 4: case 5: return t }var n = 3 === e ? "string" : 5 === e ? "number" : "default", i = E(t, r); if (void 0 !== i) { var o = i.call(t, n); if (P(o)) throw new TypeError; return o } return function (t, e) { if ("string" === e) { var n = t.toString; if (x(n) && !P(i = n.call(t))) return i; if (x(r = t.valueOf) && !P(i = r.call(t))) return i } else { var r; if (x(r = t.valueOf) && !P(i = r.call(t))) return i; var i, o = t.toString; if (x(o) && !P(i = o.call(t))) return i } throw new TypeError }(t, "default" === n ? "number" : n) } function S(t) { var e = A(t, 3); return "symbol" == typeof e ? e : function (t) { return "" + t }(e) } function T(t) { return Array.isArray ? Array.isArray(t) : t instanceof Object ? t instanceof Array : "[object Array]" === Object.prototype.toString.call(t) } function x(t) { return "function" == typeof t } function O(t) { return "function" == typeof t } function E(t, e) { var n = t[e]; if (null != n) { if (!x(n)) throw new TypeError; return n } } function R(t) { var e = t.next(); return !e.done && e } function M(t) { var e = t.return; e && e.call(t) } function F(t) { var e = Object.getPrototypeOf(t); if ("function" != typeof t || t === u) return e; if (e !== u) return e; var n = t.prototype, r = n && Object.getPrototypeOf(n); if (null == r || r === Object.prototype) return e; var i = r.constructor; return "function" != typeof i || i === t ? e : i } function G(t) { return t.__ = void 0, delete t.__, t } t("decorate", (function (t, e, n, r) { if (B(n)) { if (!T(t)) throw new TypeError; if (!O(e)) throw new TypeError; return function (t, e) { for (var n = t.length - 1; n >= 0; --n) { var r = (0, t[n])(e); if (!B(r) && !C(r)) { if (!O(r)) throw new TypeError; e = r } } return e }(t, e) } if (!T(t)) throw new TypeError; if (!P(e)) throw new TypeError; if (!P(r) && !B(r) && !C(r)) throw new TypeError; return C(r) && (r = void 0), function (t, e, n, r) { for (var i = t.length - 1; i >= 0; --i) { var o = (0, t[i])(e, n, r); if (!B(o) && !C(o)) { if (!P(o)) throw new TypeError; r = o } } return r }(t, e, n = S(n), r) })), t("metadata", (function (t, e) { return function (n, r) { if (!P(n)) throw new TypeError; if (!B(r) && !function (t) { switch (k(t)) { case 3: case 4: return !0; default: return !1 } }(r)) throw new TypeError; b(t, e, n, r) } })), t("defineMetadata", (function (t, e, n, r) { if (!P(n)) throw new TypeError; return B(r) || (r = S(r)), b(t, e, n, r) })), t("hasMetadata", (function (t, e, n) { if (!P(e)) throw new TypeError; return B(n) || (n = S(n)), y(t, e, n) })), t("hasOwnMetadata", (function (t, e, n) { if (!P(e)) throw new TypeError; return B(n) || (n = S(n)), g(t, e, n) })), t("getMetadata", (function (t, e, n) { if (!P(e)) throw new TypeError; return B(n) || (n = S(n)), m(t, e, n) })), t("getOwnMetadata", (function (t, e, n) { if (!P(e)) throw new TypeError; return B(n) || (n = S(n)), v(t, e, n) })), t("getMetadataKeys", (function (t, e) { if (!P(t)) throw new TypeError; return B(e) || (e = S(e)), w(t, e) })), t("getOwnMetadataKeys", (function (t, e) { if (!P(t)) throw new TypeError; return B(e) || (e = S(e)), _(t, e) })), t("deleteMetadata", (function (t, e, n) { if (!P(e)) throw new TypeError; B(n) || (n = S(n)); var r = d(e, n, !1); if (B(r)) return !1; if (!r.delete(t)) return !1; if (r.size > 0) return !0; var i = h.get(e); return i.delete(n), i.size > 0 || h.delete(e), !0 })) }(i) }() }(r || (r = {})) }, 554: function (t, e, n) { "use strict"; var r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.BleSessionError = void 0; const i = n(953), o = r(n(494)); class s extends Error { constructor(t) { super(t), this.name = "ScanTimeoutError" } } class a extends Error { constructor(t) { super(t), this.name = "BleSessionError" } } e.BleSessionError = a; class c extends i.PixelSession { constructor(t) { var e; super(t); const n = o.default.getKnownDevice(t); if (!n) throw new a(`No known Bluetooth device with system id: ${t}`); this._device = n, this._name = null !== (e = this._device.name) && void 0 !== e ? e : "" } get pixelName() { return this._name } async connect() { var t, e; this._name = null !== (t = this._device.name) && void 0 !== t ? t : ""; const n = this; this._device.addEventListener("gattserverdisconnected", (() => { n._notifyConnectionEvent("disconnected") })); const r = this._device.gatt; if (r && !r.connected) { try { this._notifyConnectionEvent("connecting"), await r.connect() } catch (t) { let i = t; if (this._device.watchAdvertisements && (null === (e = null == i ? void 0 : i.message) || void 0 === e ? void 0 : e.includes("no longer in range"))) try { await async function (t) { return new Promise(((e, n) => { const r = setTimeout((() => { i.abort(), n(new s) }), 5e3), i = new AbortController; t.addEventListener("advertisementreceived", (() => { clearTimeout(r), i.abort(), e() })), t.watchAdvertisements({ signal: i.signal }).catch((t => n(t))) })) }(this._device), await r.connect(), i = void 0 } catch (t) { t instanceof s || (i = t) } if (i) throw n._notifyConnectionEvent("disconnected"), i } this._notifyConnectionEvent("connected"); const t = await r.getPrimaryService(i.PixelBleUuids.service); this._notify = await t.getCharacteristic(i.PixelBleUuids.notifyCharacteristic), this._write = await t.getCharacteristic(i.PixelBleUuids.writeCharacteristic), this._notifyConnectionEvent("ready") } } async disconnect() { var t; null === (t = this._device.gatt) || void 0 === t || t.disconnect() } async subscribe(t) { if (!this._notify) throw new a("Not connected"); function e() { var e, n; (null === (n = null === (e = this.value) || void 0 === e ? void 0 : e.buffer) || void 0 === n ? void 0 : n.byteLength) && t(this.value) } const n = this._notify; return n.addEventListener("characteristicvaluechanged", e), await n.startNotifications(), () => { n.removeEventListener("characteristicvaluechanged", e) } } async writeValue(t, e, n) { if (!this._write) throw new a("Not connected"); e ? await this._write.writeValueWithoutResponse(t) : await this._write.writeValueWithResponse(t) } } e.default = c }, 494: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const r = n(953), i = new Map, o = { requestDevice: async () => { var t; if (!(null === (t = null === navigator || void 0 === navigator ? void 0 : navigator.bluetooth) || void 0 === t ? void 0 : t.requestDevice)) throw new Error("Bluetooth is not available, check that you're running in a secure environment and that Web Bluetooth is enabled."); const e = await navigator.bluetooth.requestDevice({ filters: [{ services: [r.PixelBleUuids.service] }] }); return i.set(e.id, e), e }, getKnownDevice: t => i.get(t), getDevice: async t => { var e; let n = i.get(t); return !n && (null === (e = null === navigator || void 0 === navigator ? void 0 : navigator.bluetooth) || void 0 === e ? void 0 : e.getDevices) && (n = (await navigator.bluetooth.getDevices()).find((e => e.id === t)), n && i.set(n.id, n)), n } }; e.default = o }, 368: function (t, e, n) { "use strict"; var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) { void 0 === r && (r = n); var i = Object.getOwnPropertyDescriptor(e, n); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[n] } }), Object.defineProperty(t, r, i) } : function (t, e, n, r) { void 0 === r && (r = n), t[r] = e[n] }), i = this && this.__exportStar || function (t, e) { for (var n in t) "default" === n || Object.prototype.hasOwnProperty.call(e, n) || r(e, t, n) }; Object.defineProperty(e, "__esModule", { value: !0 }), i(n(953), e), i(n(43), e), i(n(695), e) }, 695: function (t, e, n) { "use strict"; var r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.getPixel = e.getPixelFromDevice = e.requestPixel = void 0; const i = n(953), o = r(n(554)), s = r(n(494)), a = new Map; function c(t) { let e = a.get(t.id); if (!e) { const n = new o.default(t.id); e = new i.Pixel(n), a.set(t.id, e) } return e } e.requestPixel = async function () { return c(await s.default.requestDevice()) }, e.getPixelFromDevice = c, e.getPixel = async function (t) { const e = a.get(t); if (e) return e; { const e = await s.default.getDevice(t); return e ? c(e) : void 0 } } }, 43: (t, e, n) => { "use strict"; n.r(e), n.d(e, { ActionMakeWebRequest: () => wt, ActionPlayAnimation: () => gt, ActionPlayAudioClip: () => vt, ActionTypeValues: () => ht, AnimationBits: () => P, AnimationGradient: () => x, AnimationGradientPattern: () => R, AnimationInstance: () => A, AnimationInstanceGradient: () => S, AnimationInstanceGradientPattern: () => O, AnimationInstanceKeyframed: () => D, AnimationInstanceNoise: () => ct, AnimationInstanceRainbow: () => Z, AnimationInstanceSimple: () => Q, AnimationKeyframed: () => j, AnimationNoise: () => U, AnimationRainbow: () => J, AnimationSimple: () => et, AnimationTypeValues: () => a, BatteryStateFlagsValues: () => Bt, Color: () => C, Color32Utils: () => r, ColorUtils: () => i, ConditionBatteryState: () => Ct, ConditionConnectionState: () => St, ConditionCrooked: () => Ft, ConditionFaceCompare: () => Ot, ConditionHandling: () => Gt, ConditionHelloGoodbye: () => Mt, ConditionIdle: () => Dt, ConditionRolling: () => jt, ConditionTypeValues: () => _t, ConnectionStateFlagsValues: () => At, Constants: () => c, DataSet: () => Vt, FaceCompareFlagsValues: () => xt, GammaUtils: () => o, HelloGoodbyeFlagsValues: () => Rt, Profile: () => lt, RemoteActionTypeValues: () => dt, RgbKeyframe: () => nt, RgbTrack: () => it, Rule: () => pt, SimpleKeyframe: () => ot, Track: () => at, facesMaskToValues: () => L, getActionTypeDisplayName: () => Ut, getAnimationTypeDisplayName: () => zt, getConditionTypeDisplayName: () => $t, getFaceIndex: () => F, getFaceMask: () => G }); var r = {}; n.r(r), n.d(r, { combineColors: () => h, getBlue: () => p, getGreen: () => f, getRed: () => l, interpolateColors: () => d, interpolateIntensity: () => y, modulateColor: () => g, rainbowWheel: () => m, toColor32: () => u }); var i = {}; n.r(i), n.d(i, { colorBytesToString: () => _, colorComponentToByte: () => k, colorToString: () => B, hsvToRgb: () => v, rgbToHsv: () => b }); var o = {}; n.r(o), n.d(o, { gamma: () => q, gamma32: () => K, gamma8: () => V, reverseGamma: () => N, reverseGamma8: () => W }); var s = n(239); const a = { none: (0, s.GP)(0), simple: (0, s.GP)(), rainbow: (0, s.GP)(), keyframed: (0, s.GP)(), gradientPattern: (0, s.GP)(), gradient: (0, s.GP)(), noise: (0, s.GP)(), cycle: (0, s.GP)(), name: (0, s.GP)() }, c = { maxLEDsCount: 20, paletteColorFromFace: 127, paletteColorFromRandom: 126, faceMaskAll: 4294967295, keyframeTimeResolutionMs: 2, currentFaceIndex: -1 }; function u(t, e = 0, n = 0) { return "number" != typeof t && (e = 255 * t.g, n = 255 * t.b, t = 255 * t.r), t << 16 | e << 8 | 255 & n } function l(t) { return t >> 16 & 255 } function f(t) { return t >> 8 & 255 } function p(t) { return 255 & t } function h(t, e) { return u(Math.max(l(t), l(e)), Math.max(f(t), f(e)), Math.max(p(t), p(e))) } function d(t, e, n, r, i) { const o = 1024, s = (i - e) * o / (r - e); return u((l(t) * (o - s) + l(n) * s) / o, (f(t) * (o - s) + f(n) * s) / o, (p(t) * (o - s) + p(n) * s) / o) } function y(t, e, n, r, i) { const o = 1024, s = (i - e) * o / (r - e); return Math.floor((t * (o - s) + n * s) / o) } function g(t, e) { return u(l(t) * e / 255, f(t) * e / 255, p(t) * e / 255) } function m(t, e) { return t < 85 ? u(3 * t * e / 255, (255 - 3 * t) * e / 255, 0) : t < 170 ? u((255 - 3 * (t -= 85)) * e / 255, 0, 3 * t * e / 255) : u(0, 3 * (t -= 170) * e / 255, (255 - 3 * t) * e / 255) } function v({ h: t, s: e, v: n }) { const r = Math.floor(6 * t), i = 6 * t - r, o = n * (1 - e), s = n * (1 - i * e), a = n * (1 - (1 - i) * e); switch (r % 6) { case 0: return { r: n, g: a, b: o }; case 1: return { r: s, g: n, b: o }; case 2: return { r: o, g: n, b: a }; case 3: return { r: o, g: s, b: n }; case 4: return { r: a, g: o, b: n }; case 5: return { r: n, g: o, b: s }; default: return { r: 0, g: 0, b: 0 } } } function b({ r: t, g: e, b: n }) { const r = Math.max(t, e, n), i = r - Math.min(t, e, n); if (0 === i) return { h: 0, s: 0, v: 0 }; { let o = 0; switch (r) { case t: o = (e - n) / i + (e < n ? 6 : 0); break; case e: o = (n - t) / i + 2; break; case n: o = (t - e) / i + 4 }return { h: o / 6, s: i / r, v: r } } } function w(t) { const e = t.toString(16); return 1 === e.length ? "0" + e : e } function _(t, e, n) { return "#" + w(t) + w(e) + w(n) } function k(t) { return Math.round(255 * Math.min(1, Math.max(0, t))) } function B({ r: t, g: e, b: n }) { return _(k(t), k(e), k(n)) } class C { get rByte() { return k(this.r) } get gByte() { return k(this.g) } get bByte() { return k(this.b) } constructor(t, e, n) { this.r = 0, this.g = 0, this.b = 0, void 0 !== t && ("string" == typeof t ? this.setWithHex(t) : void 0 === e ? this.setWithValue(t) : this.set(t, e, null != n ? n : 0)) } equals(t) { return this.r === t.r && this.g === t.g && this.b === t.b } duplicate() { return new C(this.r, this.g, this.b) } desaturate() { return .5 * (Math.min(this.r, Math.min(this.g, this.b)) + Math.max(this.r, Math.max(this.g, this.b))) } serialize(t, e = 0) { return t.setUint8(e++, this.rByte), t.setUint8(e++, this.gByte), t.setUint8(e++, this.bByte), [t, e] } toString() { return B(this) } toColor32() { return u(this) } set(t, e, n) { return this.r = t, this.g = e, this.b = n, this } setWithBytes(t, e, n) { return this.r = t / 255, this.g = e / 255, this.b = n / 255, this } setWithValue(t) { return this.setWithBytes(l(t), f(t), p(t)), this } setWithHex(t) { if (t.length) { const e = "#" === t[0] ? 1 : 0; if (t.length === 3 + e) this.set(parseInt(t[e], 16) / 255, parseInt(t[e + 1], 16) / 255, parseInt(t[e + 2], 16) / 255); else { if (t.length !== 6 + e) throw new Error(`Invalid hexadecimal color: ${t}`); this.setWithValue(parseInt(e ? t.slice(e) : t, 16)) } } return this } static fromBytes(t, e, n) { return (new C).setWithBytes(t, e, n) } static fromString(t) { return (new C).setWithHex(t) } } C.black = new C(0, 0, 0), C.brightRed = new C(1, 0, 0), C.brightGreen = new C(0, 1, 0), C.brightBlue = new C(0, 0, 1), C.brightWhite = new C(1, 1, 1), C.brightCyan = new C(0, 1, 1), C.brightMagenta = new C(1, 0, 1), C.brightYellow = new C(1, .922, .016), C.brightOrange = new C(1, .647, 0), C.red = new C(.7, 0, 0), C.green = new C(0, .7, 0), C.blue = new C(0, 0, .7), C.white = new C(.7, .7, .7), C.cyan = new C(0, .7, .7), C.magenta = new C(.7, 0, .7), C.yellow = new C(.7, .6, .01), C.orange = new C(.7, .453, 0), C.dimRed = new C(.35, 0, 0), C.dimGreen = new C(0, .35, 0), C.dimBlue = new C(0, 0, .35), C.dimWhite = new C(.35, .35, .35), C.dimCyan = new C(0, .35, .35), C.dimMagenta = new C(.35, 0, .35), C.dimYellow = new C(.35, .3, .005), C.dimOrange = new C(.35, .226, 0); class P { constructor() { this.palette = [], this.rgbKeyframes = [], this.rgbTracks = [], this.keyframes = [], this.tracks = [] } getColor32(t) { return u(this.getColor(t)) } getColor(t) { return t === c.paletteColorFromFace ? C.blue : t === c.paletteColorFromRandom ? C.black : this.getArrayItem(this.palette, t, "color") } getPaletteSize() { return 3 * this.palette.length } getRgbKeyframe(t) { return this.getArrayItem(this.rgbKeyframes, t, "rgb keyframe") } getRgbKeyframeCount() { return this.rgbKeyframes.length } getKeyframe(t) { return this.getArrayItem(this.keyframes, t, "keyframe") } getKeyframeCount() { return this.keyframes.length } getRgbTrack(t) { return this.getArrayItem(this.rgbTracks, t, "rgb track") } getRgbTrackCount() { return this.rgbTracks.length } getTrack(t) { return this.getArrayItem(this.tracks, t, "track") } getTrackCount() { return this.tracks.length } computeDataSize() { return (0, s.EV)(3 * this.palette.length) + (0, s.iR)(this.rgbKeyframes) + (0, s.iR)(this.rgbTracks) + (0, s.iR)(this.keyframes) + (0, s.iR)(this.tracks) } serialize(t, e = 0) { return this.palette.forEach((n => { [t, e] = n.serialize(t, e) })), e = (0, s.EV)(e), [t, e] = (0, s.qC)(this.rgbKeyframes, { dataView: t, byteOffset: e }), [t, e] = (0, s.qC)(this.rgbTracks, { dataView: t, byteOffset: e }), [t, e] = (0, s.qC)(this.keyframes, { dataView: t, byteOffset: e }), [t, e] = (0, s.qC)(this.tracks, { dataView: t, byteOffset: e }), [t, e] } getArrayItem(t, e, n) { const r = t[e]; if (void 0 === r) throw e < 0 || e >= t.length ? new Error(`Out of bound index for AnimationBits.${n}, got ${e} but array has ${t.length} item(s)`) : new Error(`No item for AnimationBits.${n} at index ${e}`); return r } } class A { get startTime() { return this._startTime } get duration() { return this._animationPreset.duration } get animationPreset() { return this._animationPreset } get animationBits() { return this._animationBits } constructor(t, e) { this._startTime = 0, this._animationPreset = t, this._animationBits = e } start(t) { this._startTime = t } } class S extends A { get preset() { return this.animationPreset } updateLEDs(t, e, n) { const r = t - this.startTime, i = this.preset, o = this.animationBits.getRgbTrack(i.gradientTrackOffset), s = 1e3 * r / i.duration, a = o.evaluateColor(this.animationBits, s); let u = 0; for (let t = 0; t < c.maxLEDsCount; ++t)0 != (i.faceMask & 1 << t) && (e[u] = t, n[u] = a, u++); return u } stop(t) { const e = this.preset; let n = 0; for (let r = 0; r < c.maxLEDsCount; ++r)0 != (e.faceMask & 1 << r) && (t[n] = r, n++); return n } } var T = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class x { constructor() { this.type = a.gradient, this.duration = 0, this.faceMask = 0, this.gradientTrackOffset = 0 } createInstance(t) { return new S(this, t) } } T([(0, s.Bg)(1, { padding: 1 })], x.prototype, "type", void 0), T([(0, s.Bg)(2)], x.prototype, "duration", void 0), T([(0, s.Bg)(4)], x.prototype, "faceMask", void 0), T([(0, s.Bg)(2, { padding: 2 })], x.prototype, "gradientTrackOffset", void 0); class O extends A { constructor() { super(...arguments), this._rgb = 0 } get preset() { return this.animationPreset } start(t) { super.start(t), this.preset.overrideWithFace && (this._rgb = this.animationBits.getColor32(c.paletteColorFromFace)) } updateLEDs(t, e, n) { const r = t - this.startTime, i = this.preset, o = 1e3 * r / i.duration, s = this.animationBits.getRgbTrack(i.gradientTrackOffset); let a = 0; a = i.overrideWithFace ? this._rgb : s.evaluateColor(this.animationBits, o); let c = 0; const u = [], l = []; for (let t = 0; t < i.trackCount; ++t) { const r = this.animationBits.getTrack(i.tracksOffset + t).evaluate(this.animationBits, a, o, u, l); for (let t = 0; t < r; ++t)e[c + t] = u[t], n[c + t] = l[t]; c += r } return c } stop(t) { const e = this.preset; let n = 0; const r = []; for (let i = 0; i < e.trackCount; ++i) { const o = this.animationBits.getRgbTrack(e.tracksOffset + i).extractLEDIndices(r); for (let e = 0; e < o; ++e)t[n + e] = r[e]; n += o } return n } } var E = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class R { constructor() { this.type = a.gradientPattern, this.duration = 0, this.tracksOffset = 0, this.trackCount = 0, this.gradientTrackOffset = 0, this.overrideWithFace = !1 } createInstance(t) { return new O(this, t) } } E([(0, s.Bg)(1, { padding: 1 })], R.prototype, "type", void 0), E([(0, s.Bg)(2)], R.prototype, "duration", void 0), E([(0, s.Bg)(2)], R.prototype, "tracksOffset", void 0), E([(0, s.Bg)(2)], R.prototype, "trackCount", void 0), E([(0, s.Bg)(2)], R.prototype, "gradientTrackOffset", void 0), E([(0, s.Bg)(1, { padding: 1 })], R.prototype, "overrideWithFace", void 0); const M = [17, 1, 19, 13, 3, 10, 8, 5, 15, 7, 9, 11, 14, 4, 12, 0, 18, 2, 16, 6]; function F(t) { return M[Math.floor(t)] } function G(t) { if ("number" == typeof t) { const e = t; return (0, s.hu)(e > 0 && e <= 32, `getFaceMask: Face value is out of range [1, 32], got ${e}`), 1 << e - 1 >>> 0 } return t.reduce(((t, e) => G(e) | t), 0) } function L(t) { return (0, s.YJ)(t).map((t => t + 1)) } class D extends A { get preset() { return this.animationPreset } updateLEDs(t, e, n) { const r = t - this.startTime, i = this.preset, o = 1e3 * r / i.duration; let s = 0; const a = [], c = []; for (let t = 0; t < i.trackCount; ++t) { const r = this.animationBits.getRgbTrack(i.tracksOffset + t).evaluate(this.animationBits, o, a, c); for (let t = 0; t < r; ++t)0 !== i.flowOrder ? e[s + t] = F(a[t]) : e[s + t] = a[t], n[s + t] = c[t]; s += r } return s } stop(t) { const e = this.preset; let n = 0; const r = []; for (let i = 0; i < e.trackCount; ++i) { const o = this.animationBits.getRgbTrack(e.tracksOffset + i).extractLEDIndices(r); for (let e = 0; e < o; ++e)t[n + e] = r[e]; n += o } return n } } var I = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class j { constructor() { this.type = a.keyframed, this.duration = 0, this.tracksOffset = 0, this.trackCount = 0, this.flowOrder = 0 } createInstance(t) { return new D(this, t) } } I([(0, s.Bg)(1, { padding: 1 })], j.prototype, "type", void 0), I([(0, s.Bg)(2)], j.prototype, "duration", void 0), I([(0, s.Bg)(2)], j.prototype, "tracksOffset", void 0), I([(0, s.Bg)(2)], j.prototype, "trackCount", void 0), I([(0, s.Bg)(1, { padding: 1 })], j.prototype, "flowOrder", void 0); var z = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class U { constructor() { this.type = a.noise, this.duration = 0, this.gradientTrackOffset = 0, this.blinkTrackOffset = 0, this.blinkCount = 0, this.blinkDuration = 0, this.fade = 0, this.faceMask = 0 } createInstance(t) { return new S(this, t) } } function $(t) { return t < 0 ? 0 : t > 255 ? 255 : Math.floor(t) } function V(t) { return H[$(t)] } function K(t) { return u(V(l(t)), V(f(t)), V(p(t))) } function q(t) { const e = V(t.rByte), n = V(t.gByte), r = V(t.bByte); return C.fromBytes(e, n, r) } function W(t) { return Y[$(t)] } function N(t) { const e = W(t.rByte), n = W(t.gByte), r = W(t.bByte); return C.fromBytes(e, n, r) } z([(0, s.Bg)(1, { padding: 1 })], U.prototype, "type", void 0), z([(0, s.Bg)(2)], U.prototype, "duration", void 0), z([(0, s.Bg)(2)], U.prototype, "gradientTrackOffset", void 0), z([(0, s.Bg)(2)], U.prototype, "blinkTrackOffset", void 0), z([(0, s.Bg)(2)], U.prototype, "blinkCount", void 0), z([(0, s.Bg)(1)], U.prototype, "blinkDuration", void 0), z([(0, s.Bg)(1)], U.prototype, "fade", void 0), z([(0, s.Bg)(4)], U.prototype, "faceMask", void 0); const H = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36, 37, 38, 39, 40, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 82, 84, 85, 87, 88, 90, 91, 93, 94, 96, 97, 99, 101, 102, 104, 105, 107, 109, 111, 112, 114, 116, 118, 119, 121, 123, 125, 127, 129, 131, 132, 134, 136, 138, 140, 142, 144, 147, 149, 151, 153, 155, 157, 159, 162, 164, 166, 168, 171, 173, 175, 178, 180, 182, 185, 187, 190, 192, 195, 197, 200, 202, 205, 207, 210, 213, 215, 218, 221, 223, 226, 229, 232, 235, 237, 240, 243, 246, 249, 252, 255], Y = [0, 70, 80, 87, 92, 97, 101, 105, 108, 112, 114, 117, 119, 122, 124, 126, 128, 130, 132, 134, 135, 137, 138, 140, 141, 143, 144, 146, 147, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 170, 171, 172, 173, 174, 174, 175, 176, 177, 177, 178, 179, 180, 180, 181, 182, 182, 183, 184, 184, 185, 186, 186, 187, 188, 188, 189, 189, 190, 191, 191, 192, 192, 193, 194, 194, 195, 195, 196, 196, 197, 197, 198, 198, 199, 200, 200, 201, 201, 202, 202, 203, 203, 204, 204, 204, 205, 205, 206, 206, 207, 207, 208, 208, 209, 209, 210, 210, 210, 211, 211, 212, 212, 213, 213, 214, 214, 214, 215, 215, 216, 216, 216, 217, 217, 218, 218, 218, 219, 219, 220, 220, 220, 221, 221, 222, 222, 222, 223, 223, 223, 224, 224, 224, 225, 225, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 237, 238, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 241, 242, 242, 242, 243, 243, 243, 243, 244, 244, 244, 245, 245, 245, 245, 246, 246, 246, 247, 247, 247, 247, 248, 248, 248, 248, 249, 249, 249, 249, 250, 250, 250, 251, 251, 251, 251, 252, 252, 252, 252, 253, 253, 253, 253, 254, 254, 254, 254, 255]; class Z extends A { get preset() { return this.animationPreset } updateLEDs(t, e, n) { const r = this.preset, i = r.duration * r.fade / 510, o = t - this.startTime, s = o * r.count * 255 / r.duration % 256; let a = 255; o <= i ? a = 255 * o / i : o >= r.duration - i && (a = 255 * (r.duration - o) / i); let u = 0; if (r.traveling) for (let t = 0; t < c.maxLEDsCount; ++t)0 != (r.faceMask & 1 << t) && (e[u] = F(t), n[u] = K(m((s + 256 * t / c.maxLEDsCount) % 256, a)), u++); else { const t = K(m(s, a)); for (let i = 0; i < c.maxLEDsCount; ++i)0 != (r.faceMask & 1 << i) && (e[u] = i, n[u] = t, u++) } return u } stop(t) { const e = this.preset; let n = 0; for (let r = 0; r < c.maxLEDsCount; ++r)0 != (e.faceMask & 1 << r) && (t[n] = r, n++); return n } } var X = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class J { constructor() { this.type = a.rainbow, this.duration = 0, this.faceMask = 0, this.count = 0, this.fade = 0, this.traveling = !1, this.intensity = 128 } createInstance(t) { return new Z(this, t) } } X([(0, s.Bg)(1, { padding: 1 })], J.prototype, "type", void 0), X([(0, s.Bg)(2)], J.prototype, "duration", void 0), X([(0, s.Bg)(4)], J.prototype, "faceMask", void 0), X([(0, s.Bg)(1)], J.prototype, "count", void 0), X([(0, s.Bg)(1)], J.prototype, "fade", void 0), X([(0, s.Bg)(1)], J.prototype, "traveling", void 0), X([(0, s.Bg)(1)], J.prototype, "intensity", void 0); class Q extends A { constructor() { super(...arguments), this._rgb = 0 } get preset() { return this.animationPreset } start(t) { super.start(t), this._rgb = this.animationBits.getColor32(this.preset.colorIndex) } updateLEDs(t, e, n) { const r = this.preset; let i = 0; const o = r.duration / r.count, s = o * r.fade / 510, a = (o - 2 * s) / 2, u = (t - this.startTime) % o; i = u <= s ? d(0, 0, this._rgb, s, u) : u <= s + a ? this._rgb : u <= 2 * s + a ? d(this._rgb, s + a, 0, 2 * s + a, u) : 0; let l = 0; for (let t = 0; t < c.maxLEDsCount; ++t)0 != (r.faceMask & 1 << t) && (e[l] = t, n[l] = i, l++); return l } stop(t) { const e = this.preset; let n = 0; for (let r = 0; r < c.maxLEDsCount; ++r)0 != (e.faceMask & 1 << r) && (t[n] = r, n++); return n } } var tt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class et { constructor() { this.type = a.simple, this.duration = 0, this.faceMask = 0, this.colorIndex = 0, this.count = 0, this.fade = 0 } createInstance(t) { return new Q(this, t) } } tt([(0, s.Bg)(1, { padding: 1 })], et.prototype, "type", void 0), tt([(0, s.Bg)(2)], et.prototype, "duration", void 0), tt([(0, s.Bg)(4)], et.prototype, "faceMask", void 0), tt([(0, s.Bg)(2)], et.prototype, "colorIndex", void 0), tt([(0, s.Bg)(1)], et.prototype, "count", void 0), tt([(0, s.Bg)(1)], et.prototype, "fade", void 0); class nt { constructor() { this.timeAndColor = 0 } get time() { return 2 * ((65535 & this.timeAndColor) >> 7) } get colorIndex() { return 127 & this.timeAndColor } getColor(t) { return t.getColor32(this.colorIndex) } setTimeAndColorIndex(t, e) { const n = Math.round(1e3 * Math.max(0, t)) / 2 & 511; this.timeAndColor = n << 7 | 127 & e } equals(t) { return this.timeAndColor === t.timeAndColor } } !function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); o > 3 && s && Object.defineProperty(e, n, s) }([(0, s.Bg)(2)], nt.prototype, "timeAndColor", void 0); var rt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class it { constructor() { this.keyframesOffset = 0, this.keyFrameCount = 0, this.ledMask = 0 } getDuration(t) { return t.getRgbKeyframe(this.keyframesOffset + this.keyFrameCount - 1).time } getKeyframe(t, e) { return (0, s.hu)(e >= 0 && e < this.keyFrameCount, `Invalid key frame index: ${e} (count: ${this.keyFrameCount})`), t.getRgbKeyframe(this.keyframesOffset + e) } evaluate(t, e, n, r) { if (0 === this.keyFrameCount) return 0; const i = this.evaluateColor(t, e); let o = 0; for (let t = 0; t < c.maxLEDsCount; ++t)0 != (this.ledMask & 1 << t) && (n[o] = t, r[o] = i, o++); return o } evaluateColor(t, e) { if (0 === this.keyFrameCount) return 0; let n = 0; for (; n < this.keyFrameCount && this.getKeyframe(t, n).time < e;)n++; let r = 0; if (0 === n) r = this.getKeyframe(t, n).getColor(t); else if (n === this.keyFrameCount) r = this.getKeyframe(t, n - 1).getColor(t); else { const i = this.getKeyframe(t, n), o = i.time, s = i.getColor(t), a = this.getKeyframe(t, n - 1), c = a.time; r = d(a.getColor(t), c, s, o, e) } return r } extractLEDIndices(t) { let e = 0; for (let n = 0; n < c.maxLEDsCount; ++n)0 != (this.ledMask & 1 << n) && (t[e] = n, e++); return e } equals(t) { return this.keyframesOffset === t.keyframesOffset && this.keyFrameCount === t.keyFrameCount && this.ledMask === t.ledMask } } rt([(0, s.Bg)(2)], it.prototype, "keyframesOffset", void 0), rt([(0, s.Bg)(1, { padding: 1 })], it.prototype, "keyFrameCount", void 0), rt([(0, s.Bg)(4)], it.prototype, "ledMask", void 0); class ot { constructor() { this.timeAndIntensity = 0 } get time() { return 2 * ((65535 & this.timeAndIntensity) >> 7) } get intensity() { return 2 * (127 & this.timeAndIntensity) } setTimeAndIntensity(t, e) { const n = Math.round(1e3 * Math.max(0, t)) / 2 & 511, r = 127 & Math.floor(e / 2); this.timeAndIntensity = n << 7 | r } equals(t) { return this.timeAndIntensity === t.timeAndIntensity } } !function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); o > 3 && s && Object.defineProperty(e, n, s) }([(0, s.Bg)(2)], ot.prototype, "timeAndIntensity", void 0); var st = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class at { constructor() { this.keyframesOffset = 0, this.keyFrameCount = 0, this.ledMask = 0 } getDuration(t) { return t.getRgbKeyframe(this.keyframesOffset + this.keyFrameCount - 1).time } getKeyframe(t, e) { return (0, s.hu)(e >= 0 && e < this.keyFrameCount, `Invalid key frame index: ${e} (count: ${this.keyFrameCount})`), t.getKeyframe(this.keyframesOffset + e) } evaluate(t, e, n, r, i) { if (0 === this.keyFrameCount) return 0; const o = g(e, this.evaluateIntensity(t, n)); let s = 0; for (let t = 0; t < c.maxLEDsCount; ++t)0 != (this.ledMask & 1 << t) && (r[s] = t, i[s] = o, s++); return s } evaluateIntensity(t, e) { let n = 0; for (; n < this.keyFrameCount && this.getKeyframe(t, n).time < e;)n++; if (0 === n) return this.getKeyframe(t, n).intensity; if (n === this.keyFrameCount) return this.getKeyframe(t, n - 1).intensity; { const r = this.getKeyframe(t, n), i = r.time, o = r.intensity, s = this.getKeyframe(t, n - 1), a = s.time; return y(s.intensity, a, o, i, e) } } extractLEDIndices(t) { let e = 0; for (let n = 0; n < c.maxLEDsCount; ++n)0 != (this.ledMask & 1 << n) && (t[e] = n, e++); return e } equals(t) { return this.keyframesOffset === t.keyframesOffset && this.keyFrameCount === t.keyFrameCount && this.ledMask === t.ledMask } } st([(0, s.Bg)(2)], at.prototype, "keyframesOffset", void 0), st([(0, s.Bg)(1, { padding: 1 })], at.prototype, "keyFrameCount", void 0), st([(0, s.Bg)(4)], at.prototype, "ledMask", void 0); class ct extends A { get preset() { return this.animationPreset } updateLEDs(t, e, n) { return 0 } stop(t) { return 0 } } var ut = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class lt { constructor() { this.rulesOffset = 0, this.rulesCount = 0 } } ut([(0, s.Bg)(2)], lt.prototype, "rulesOffset", void 0), ut([(0, s.Bg)(2)], lt.prototype, "rulesCount", void 0); var ft = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class pt { constructor() { this.condition = 0, this.actionOffset = 0, this.actionCount = 0, this.actionCountPadding = 0 } } ft([(0, s.Bg)(2)], pt.prototype, "condition", void 0), ft([(0, s.Bg)(2)], pt.prototype, "actionOffset", void 0), ft([(0, s.Bg)(2)], pt.prototype, "actionCount", void 0), ft([(0, s.Bg)(2)], pt.prototype, "actionCountPadding", void 0); const ht = { none: (0, s.GP)(0), playAnimation: (0, s.GP)(), runOnDevice: (0, s.GP)() }, dt = { none: (0, s.GP)(0), playAudioClip: (0, s.GP)(), makeWebRequest: (0, s.GP)() }; var yt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class gt { constructor() { this.type = ht.playAnimation, this.animIndex = 0, this.faceIndex = 0, this.loopCount = 0 } } yt([(0, s.Bg)(1)], gt.prototype, "type", void 0), yt([(0, s.Bg)(1)], gt.prototype, "animIndex", void 0), yt([(0, s.Bg)(1, { numberFormat: "signed" })], gt.prototype, "faceIndex", void 0), yt([(0, s.Bg)(1)], gt.prototype, "loopCount", void 0); var mt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class vt { constructor() { this.type = ht.runOnDevice, this.remoteType = dt.playAudioClip, this.actionId = 0 } } mt([(0, s.Bg)(1)], vt.prototype, "type", void 0), mt([(0, s.Bg)(1)], vt.prototype, "remoteType", void 0), mt([(0, s.Bg)(2)], vt.prototype, "actionId", void 0); var bt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class wt { constructor() { this.type = ht.runOnDevice, this.remoteType = dt.makeWebRequest, this.actionId = 0 } } bt([(0, s.Bg)(1)], wt.prototype, "type", void 0), bt([(0, s.Bg)(1)], wt.prototype, "remoteType", void 0), bt([(0, s.Bg)(2)], wt.prototype, "actionId", void 0); const _t = { none: (0, s.GP)(0), helloGoodbye: (0, s.GP)(), handling: (0, s.GP)(), rolling: (0, s.GP)(), faceCompare: (0, s.GP)(), crooked: (0, s.GP)(), connectionState: (0, s.GP)(), batteryState: (0, s.GP)(), idle: (0, s.GP)() }; var kt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; const Bt = { ok: (0, s.mU)(0), low: (0, s.mU)(), charging: (0, s.mU)(), done: (0, s.mU)(), badCharging: (0, s.mU)(), error: (0, s.mU)() }; class Ct { constructor() { this.type = _t.batteryState, this.flags = 0, this.repeatPeriodMs = 0 } } kt([(0, s.Bg)(1)], Ct.prototype, "type", void 0), kt([(0, s.Bg)(1)], Ct.prototype, "flags", void 0), kt([(0, s.Bg)(2)], Ct.prototype, "repeatPeriodMs", void 0); var Pt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; const At = { connected: (0, s.mU)(0), disconnected: (0, s.mU)() }; class St { constructor() { this.type = _t.connectionState, this.flags = 0 } } Pt([(0, s.Bg)(1)], St.prototype, "type", void 0), Pt([(0, s.Bg)(1, { padding: 2 })], St.prototype, "flags", void 0); var Tt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; const xt = { less: (0, s.mU)(0), equal: (0, s.mU)(), greater: (0, s.mU)() }; class Ot { constructor() { this.type = _t.faceCompare, this.faceIndex = 0, this.flags = 0 } } Tt([(0, s.Bg)(1)], Ot.prototype, "type", void 0), Tt([(0, s.Bg)(1)], Ot.prototype, "faceIndex", void 0), Tt([(0, s.Bg)(1, { padding: 1 })], Ot.prototype, "flags", void 0); var Et = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; const Rt = { hello: (0, s.mU)(0), goodbye: (0, s.mU)() }; class Mt { constructor() { this.type = _t.helloGoodbye, this.flags = 0 } } Et([(0, s.Bg)(1)], Mt.prototype, "type", void 0), Et([(0, s.Bg)(1, { padding: 2 })], Mt.prototype, "flags", void 0); class Ft { constructor() { this.type = _t.crooked } } !function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); o > 3 && s && Object.defineProperty(e, n, s) }([(0, s.Bg)(1, { padding: 3 })], Ft.prototype, "type", void 0); class Gt { constructor() { this.type = _t.handling } } !function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); o > 3 && s && Object.defineProperty(e, n, s) }([(0, s.Bg)(1, { padding: 3 })], Gt.prototype, "type", void 0); var Lt = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class Dt { constructor() { this.type = _t.idle, this.repeatPeriodMs = 0 } } Lt([(0, s.Bg)(1, { padding: 1 })], Dt.prototype, "type", void 0), Lt([(0, s.Bg)(2)], Dt.prototype, "repeatPeriodMs", void 0); var It = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; class jt { constructor() { this.type = _t.rolling, this.repeatPeriodMs = 0 } } function zt(t) { switch (t) { case "none": return; case "simple": return { name: "Simple Flashes", order: 0 }; case "rainbow": return { name: "Colorful Rainbow", order: 1 }; case "keyframed": return { name: "Color LED Pattern", order: 3 }; case "gradientPattern": return { name: "Gradient LED Pattern", order: 4 }; case "gradient": return { name: "Simple Gradient", order: 2 }; case "noise": return { name: "Noise", order: 5 }; case "cycle": case "name": throw new Error(`getAnimationTypeDisplayName: unsupported animation type: ${t}`); default: (0, s.vE)(t, `Unknown animation type: ${t}`) } } function Ut(t, e = "none") { switch (t) { case "none": return; case "playAnimation": return { name: "Trigger Pattern", order: 0 }; case "runOnDevice": switch (e) { case "none": return; case "playAudioClip": return { name: "Play Audio Clip", order: 1 }; case "makeWebRequest": return { name: "Make Web Request", order: 2 }; default: (0, s.vE)(e, `Unknown action remote type: ${e}`) }break; default: (0, s.vE)(t, `Unknown action type: ${t}`) } } function $t(t) { switch (t) { case "none": return; case "helloGoodbye": return { name: "Pixel wakes up / sleeps", order: 0 }; case "handling": return { name: "Pixel is picked up", order: 1 }; case "rolling": return { name: "Pixel is rolling", order: 2 }; case "faceCompare": return { name: "Pixel roll is...", order: 3 }; case "crooked": return { name: "Pixel is crooked", order: 4 }; case "connectionState": return { name: "Bluetooth Event...", order: 5 }; case "batteryState": return { name: "Battery Event...", order: 6 }; case "idle": return { name: "Pixel is idle for...", order: 7 }; default: (0, s.vE)(t, `Unknown condition type: ${t}`) } } It([(0, s.Bg)(1, { padding: 1 })], jt.prototype, "type", void 0), It([(0, s.Bg)(2)], jt.prototype, "repeatPeriodMs", void 0); class Vt { get animationBits() { return this._animationBits } get animations() { return this._animations } get conditions() { return this._conditions } get actions() { return this._actions } get rules() { return this._rules } get profile() { return this._profile } set profile(t) { this._profile = t } constructor(t) { this._animations = [], this._conditions = [], this._actions = [], this._rules = [], this._profile = new lt, this._animationBits = null != t ? t : new P } computeDataSetByteSize() { return this._animationBits.computeDataSize() + (0, s.EV)(2 * this._animations.length) + (0, s.iR)(this._animations) + (0, s.EV)(2 * this._conditions.length) + (0, s.iR)(this._conditions) + (0, s.EV)(2 * this._actions.length) + (0, s.iR)(this._actions) + (0, s.iR)(this._rules) + (this._profile ? (0, s.iR)(this._profile) : 0) } toSingleAnimationByteArray() { (0, s.hu)(1 === this._animations.length, "Need exactly one animation"), (0, s.hu)(this._animationBits.palette.length <= 127, "Palette has more than 127 colors: " + this._animationBits.palette.length); const t = this._animationBits.computeDataSize() + (0, s.iR)(this._animations[0]), [e, n] = this._animationBits.serialize(new DataView(new ArrayBuffer(t))); return (0, s.qC)(this._animations[0], { dataView: e, byteOffset: n }), new Uint8Array(e.buffer) } toAnimationsByteArray() { (0, s.hu)(this._animations.length > 0, "No animations"), (0, s.hu)(this._animationBits.palette.length <= 127, "Palette has more than 127 colors: " + this._animationBits.palette.length); const t = this._animationBits.computeDataSize() + (0, s.EV)(2 * this._animations.length) + (0, s.iR)(this._animations); let [e, n] = this._animationBits.serialize(new DataView(new ArrayBuffer(t))), r = 0; return this._animations.forEach(((t, i) => { e.setUint16(n + 2 * i, r, !0), r += (0, s.iR)(t) })), n += (0, s.EV)(2 * this._animations.length), [e, n] = (0, s.qC)(this._animations, { dataView: e, byteOffset: n }), new Uint8Array(e.buffer) } toByteArray() { const t = this.computeDataSetByteSize(), [e] = this.serialize(new DataView(new ArrayBuffer(t))); return new Uint8Array(e.buffer) } serialize(t, e = 0) { (0, s.hu)(this._animationBits.palette.length <= 127, "Palette has more than 127 colors: " + this._animationBits.palette.length), [t, e] = this._animationBits.serialize(t); let n = 0; this._animations.forEach(((r, i) => { t.setUint16(e + 2 * i, n, !0), n += (0, s.iR)(r) })), e += (0, s.EV)(2 * this._animations.length), [t, e] = (0, s.qC)(this._animations, { dataView: t, byteOffset: e }); let r = 0; this._conditions.forEach(((n, i) => { t.setUint16(e + 2 * i, r, !0), r += (0, s.iR)(n) })), e += (0, s.EV)(2 * this._conditions.length), [t, e] = (0, s.qC)(this._conditions, { dataView: t, byteOffset: e }); let i = 0; return this._actions.forEach(((n, r) => { t.setUint16(e + 2 * r, i, !0), i += (0, s.iR)(n) })), e += (0, s.EV)(2 * this._actions.length), [t, e] = (0, s.qC)(this._actions, { dataView: t, byteOffset: e }), [t, e] = (0, s.qC)(this._rules, { dataView: t, byteOffset: e }), this._profile && ([t, e] = (0, s.qC)(this._profile, { dataView: t, byteOffset: e })), [t, e] } static computeHash(t) { return (0, s.yh)(t) } } }, 953: (t, e, n) => { "use strict"; function r(t) { return `${t.name}$[${t.pixelId}]` } n.r(e), n.d(e, { BatteryLevel: () => W, Blink: () => K, BlinkId: () => ot, BulkData: () => M, BulkDataAck: () => F, BulkSetup: () => R, DebugLog: () => z, Discharge: () => it, GenericPixelMessage: () => A, IAmADie: () => T, LEDLoopback: () => X, MessageTypeValues: () => g, NotifyUser: () => Y, NotifyUserAck: () => Z, Pixel: () => yt, PixelBatteryStateValues: () => q, PixelBleUuids: () => c, PixelDesignAndColorValues: () => S, PixelInfoNotifier: () => u, PixelRollStateValues: () => x, PixelSession: () => l, PlayInstantAnimation: () => nt, RemoteAction: () => U, RequestRssi: () => N, RequestTelemetry: () => V, RollState: () => O, Rssi: () => H, SetDesignAndColor: () => J, SetName: () => Q, Telemetry: () => E, TelemetryRequestModeValues: () => $, Temperature: () => rt, TransferAnimationSet: () => G, TransferAnimationSetAck: () => L, TransferInstantAnimationSet: () => tt, TransferInstantAnimationSetAck: () => et, TransferInstantAnimationsSetAckTypeValues: () => I, TransferTest: () => st, TransferTestAnimationSet: () => D, TransferTestAnimationSetAck: () => j, deserializeMessage: () => P, getMessageType: () => k, getMessageTypeValue: () => _, getPixelUniqueName: () => r, instantiateMessage: () => B, repeatConnect: () => s, serializeMessage: () => C, toFullUuid: () => a }); var i = n(239); async function o(t, e, n, r) { var s, a, c; try { const t = await n(); null === (s = null == r ? void 0 : r.onResolved) || void 0 === s || s.call(r, t) } catch (s) { if (0 === t) throw null === (c = null == r ? void 0 : r.onRejected) || void 0 === c || c.call(r, s), s; null === (a = null == r ? void 0 : r.onWillRetry) || void 0 === a || a.call(r, e, t, s), await (0, i.gw)(e), await o(t - 1, 2 * e, n, r) } } async function s(t, e) { var n; await o(null !== (n = null == e ? void 0 : e.retries) && void 0 !== n ? n : 2, 1e3, t.connect.bind(t), e) } function a(t) { return (4294967295 & t).toString(16).padStart(8, "0") + "-0000-1000-8000-00805f9b34fb" } const c = { service: "6e400001-b5a3-f393-e0a9-e50e24dcca9e", notifyCharacteristic: "6e400001-b5a3-f393-e0a9-e50e24dcca9e", writeCharacteristic: "6e400002-b5a3-f393-e0a9-e50e24dcca9e", dfuService: 65113 }; class u { constructor() { this._infoEvEmitter = (0, i.W2)() } addPropertyListener(t, e) { this._infoEvEmitter.addListener(t, e) } removePropertyListener(t, e) { this._infoEvEmitter.removeListener(t, e) } emitPropertyEvent(t) { this._infoEvEmitter.emit(t, this) } } class l { constructor(t) { this._pixelSystemId = t, this._lastConnStatus = "disconnected" } get pixelSystemId() { return this._pixelSystemId } get lastConnectionStatus() { return this._lastConnStatus } setConnectionEventListener(t) { this._connStatusCb = t } _notifyConnectionEvent(t) { var e; this._lastConnStatus !== t && (this._lastConnStatus = t, null === (e = this._connStatusCb) || void 0 === e || e.call(this, { pixelSystemId: this._pixelSystemId, connectionStatus: t })) } } var f = n(43), p = n(699); const h = 5e3, d = 100; var y = function (t, e, n, r) { var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s); return o > 3 && s && Object.defineProperty(e, n, s), s }; const g = { none: (0, i.GP)(0), whoAreYou: (0, i.GP)(), iAmADie: (0, i.GP)(), rollState: (0, i.GP)(), telemetry: (0, i.GP)(), bulkSetup: (0, i.GP)(), bulkSetupAck: (0, i.GP)(), bulkData: (0, i.GP)(), bulkDataAck: (0, i.GP)(), transferAnimationSet: (0, i.GP)(), transferAnimationSetAck: (0, i.GP)(), transferAnimationSetFinished: (0, i.GP)(), transferSettings: (0, i.GP)(), transferSettingsAck: (0, i.GP)(), transferSettingsFinished: (0, i.GP)(), transferTestAnimationSet: (0, i.GP)(), transferTestAnimationSetAck: (0, i.GP)(), transferTestAnimationSetFinished: (0, i.GP)(), debugLog: (0, i.GP)(), playAnimation: (0, i.GP)(), playAnimationEvent: (0, i.GP)(), stopAnimation: (0, i.GP)(), remoteAction: (0, i.GP)(), requestRollState: (0, i.GP)(), requestAnimationSet: (0, i.GP)(), requestSettings: (0, i.GP)(), requestTelemetry: (0, i.GP)(), programDefaultAnimationSet: (0, i.GP)(), programDefaultAnimationSetFinished: (0, i.GP)(), blink: (0, i.GP)(), blinkAck: (0, i.GP)(), requestDefaultAnimationSetColor: (0, i.GP)(), defaultAnimationSetColor: (0, i.GP)(), requestBatteryLevel: (0, i.GP)(), batteryLevel: (0, i.GP)(), requestRssi: (0, i.GP)(), rssi: (0, i.GP)(), calibrate: (0, i.GP)(), calibrateFace: (0, i.GP)(), notifyUser: (0, i.GP)(), notifyUserAck: (0, i.GP)(), testHardware: (0, i.GP)(), testLEDLoopback: (0, i.GP)(), ledLoopback: (0, i.GP)(), setTopLevelState: (0, i.GP)(), programDefaultParameters: (0, i.GP)(), programDefaultParametersFinished: (0, i.GP)(), setDesignAndColor: (0, i.GP)(), setDesignAndColorAck: (0, i.GP)(), setCurrentBehavior: (0, i.GP)(), setCurrentBehaviorAck: (0, i.GP)(), setName: (0, i.GP)(), setNameAck: (0, i.GP)(), sleep: (0, i.GP)(), exitValidation: (0, i.GP)(), transferInstantAnimationSet: (0, i.GP)(), transferInstantAnimationSetAck: (0, i.GP)(), transferInstantAnimationSetFinished: (0, i.GP)(), playInstantAnimation: (0, i.GP)(), stopAllAnimations: (0, i.GP)(), requestTemperature: (0, i.GP)(), temperature: (0, i.GP)(), enableCharging: (0, i.GP)(), disableCharging: (0, i.GP)(), discharge: (0, i.GP)(), blinkId: (0, i.GP)(), blinkIdAck: (0, i.GP)(), transferTest: (0, i.GP)(), transferTestAck: (0, i.GP)(), transferTestFinished: (0, i.GP)(), testBulkSend: (0, i.GP)(), testBulkReceive: (0, i.GP)(), setAllLEDsToColor: (0, i.GP)(), attractMode: (0, i.GP)(), printNormals: (0, i.GP)(), printA2DReadings: (0, i.GP)(), lightUpFace: (0, i.GP)(), setLEDToColor: (0, i.GP)(), debugAnimationController: (0, i.GP)() }, m = [], v = new Map, b = new Map; function w(t) { const e = g[t]; return (0, i.hu)(e, `No Pixel message type value for ${t}`), e } function _(t) { return "function" == typeof t ? function (t) { var e; if (!v) { const t = v; at().forEach((e => { t.set(e, (new e).type) })) } return null !== (e = v.get(t)) && void 0 !== e ? e : g.none }(t) : "string" == typeof t ? w(t) : t.type } function k(t) { if ("string" == typeof t) return t; { const e = "number" == typeof t ? t : t.type, n = function (t) { if (!m.length) { const t = m; for (const [e, n] of Object.entries(g)) t[n] = e } return m[t] }(e); if (n) return n; throw Error(`getMessageName: ${e} is not a value in MessageTypeValues`) } } function B(t) { const e = w(t), n = function (t) { if (!b.size) { const t = b; at().forEach((e => { t.set((new e).type, e) })) } return b.get(t) }(e); return n ? new n : new A(e) } function C(t) { if ("object" == typeof t) { const e = t, [n] = (0, i.qC)(e); return (0, i.hu)(n.byteLength > 0, "Got empty buffer from deserialization"), (0, i.hu)(n.getUint8(0) === _(e), `Unexpected message type, got ${n.getUint8(0)} instead of ${_(e)}`), n.buffer } { const e = "number" == typeof t ? t : g[t]; return (0, i.hu)(e, `No Pixel message value for ${t}`), Uint8Array.of(e) } } function P(t) { if (!(null == t ? void 0 : t.byteLength)) throw new i.TH("Can't deserialize an empty buffer"); const e = new DataView(t), n = e.getUint8(0); if (1 === t.byteLength) return k(n); { const r = B(k(n)), [o, s] = (0, i.vB)(r, e); return s !== t.byteLength && console.log(`The last ${t.byteLength - s} bytes were not read while deserializing message of type ${r.type}`), (0, i.hu)(r.type === n, `Incorrect message type after deserializing ${r.type} but expecting ${n}`), r } } class A { constructor(t) { this.type = t } } y([(0, i.Bg)(1)], A.prototype, "type", void 0); const S = { unknown: (0, i.GP)(0), generic: (0, i.GP)(), v3Orange: (0, i.GP)(), v4BlackClear: (0, i.GP)(), v4WhiteClear: (0, i.GP)(), v5Grey: (0, i.GP)(), v5White: (0, i.GP)(), v5Black: (0, i.GP)(), v5Gold: (0, i.GP)(), onyxBlack: (0, i.GP)(), hematiteGrey: (0, i.GP)(), midnightGalaxy: (0, i.GP)(), auroraSky: (0, i.GP)() }; class T { constructor() { this.type = g.iAmADie, this.ledCount = 0, this.designAndColor = S.generic, this.dataSetHash = 0, this.pixelId = 0, this.availableFlashSize = 0, this.buildTimestamp = 0, this.rollState = x.unknown, this.currentFaceIndex = 0, this.batteryLevelPercent = 0, this.batteryState = q.ok } } y([(0, i.Bg)(1)], T.prototype, "type", void 0), y([(0, i.Bg)(1)], T.prototype, "ledCount", void 0), y([(0, i.Bg)(1, { padding: 1 })], T.prototype, "designAndColor", void 0), y([(0, i.Bg)(4)], T.prototype, "dataSetHash", void 0), y([(0, i.Bg)(4)], T.prototype, "pixelId", void 0), y([(0, i.Bg)(2)], T.prototype, "availableFlashSize", void 0), y([(0, i.Bg)(4)], T.prototype, "buildTimestamp", void 0), y([(0, i.Bg)(1)], T.prototype, "rollState", void 0), y([(0, i.Bg)(1)], T.prototype, "currentFaceIndex", void 0), y([(0, i.Bg)(1)], T.prototype, "batteryLevelPercent", void 0), y([(0, i.Bg)(1)], T.prototype, "batteryState", void 0); const x = { unknown: (0, i.GP)(0), onFace: (0, i.GP)(), handling: (0, i.GP)(), rolling: (0, i.GP)(), crooked: (0, i.GP)() }; class O { constructor() { this.type = g.rollState, this.state = x.unknown, this.faceIndex = 0 } } y([(0, i.Bg)(1)], O.prototype, "type", void 0), y([(0, i.Bg)(1)], O.prototype, "state", void 0), y([(0, i.Bg)(1)], O.prototype, "faceIndex", void 0); class E { constructor() { this.type = g.telemetry, this.accX = 0, this.accY = 0, this.accZ = 0, this.jerkX = 0, this.jerkY = 0, this.jerkZ = 0, this.smoothAccX = 0, this.smoothAccY = 0, this.smoothAccZ = 0, this.sigma = 0, this.faceConfidence = 0, this.time = 0, this.rollState = x.unknown, this.faceIndex = 0, this.batteryLevelPercent = 0, this.batteryState = q.ok, this.voltageTimes50 = 0, this.vCoilTimes50 = 0, this.rssi = 0, this.channelIndex = 0, this.mcuTemperatureTimes100 = 0, this.batteryTemperatureTimes100 = 0, this.internalChargeState = !1, this.forceDisableChargingState = !1 } } y([(0, i.Bg)(1)], E.prototype, "type", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "accX", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "accY", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "accZ", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "jerkX", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "jerkY", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "jerkZ", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "smoothAccX", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "smoothAccY", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "smoothAccZ", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "sigma", void 0), y([(0, i.Bg)(4, { numberFormat: "float" })], E.prototype, "faceConfidence", void 0), y([(0, i.Bg)(4)], E.prototype, "time", void 0), y([(0, i.Bg)(1)], E.prototype, "rollState", void 0), y([(0, i.Bg)(1)], E.prototype, "faceIndex", void 0), y([(0, i.Bg)(1)], E.prototype, "batteryLevelPercent", void 0), y([(0, i.Bg)(1)], E.prototype, "batteryState", void 0), y([(0, i.Bg)(1)], E.prototype, "voltageTimes50", void 0), y([(0, i.Bg)(1)], E.prototype, "vCoilTimes50", void 0), y([(0, i.Bg)(1, { numberFormat: "signed" })], E.prototype, "rssi", void 0), y([(0, i.Bg)(1)], E.prototype, "channelIndex", void 0), y([(0, i.Bg)(2)], E.prototype, "mcuTemperatureTimes100", void 0), y([(0, i.Bg)(2)], E.prototype, "batteryTemperatureTimes100", void 0), y([(0, i.Bg)(1)], E.prototype, "internalChargeState", void 0), y([(0, i.Bg)(1)], E.prototype, "forceDisableChargingState", void 0); class R { constructor() { this.type = g.bulkSetup, this.size = 0 } } y([(0, i.Bg)(1)], R.prototype, "type", void 0), y([(0, i.Bg)(2)], R.prototype, "size", void 0); class M { constructor() { this.type = g.bulkData, this.size = 0, this.offset = 0 } } y([(0, i.Bg)(1)], M.prototype, "type", void 0), y([(0, i.Bg)(1)], M.prototype, "size", void 0), y([(0, i.Bg)(2)], M.prototype, "offset", void 0), y([(0, i.Bg)(d)], M.prototype, "data", void 0); class F { constructor() { this.type = g.bulkDataAck, this.offset = 0 } } y([(0, i.Bg)(1)], F.prototype, "type", void 0), y([(0, i.Bg)(2)], F.prototype, "offset", void 0); class G { constructor() { this.type = g.transferAnimationSet, this.paletteSize = 0, this.rgbKeyFrameCount = 0, this.rgbTrackCount = 0, this.keyFrameCount = 0, this.trackCount = 0, this.animationCount = 0, this.animationSize = 0, this.conditionCount = 0, this.conditionSize = 0, this.actionCount = 0, this.actionSize = 0, this.ruleCount = 0 } } y([(0, i.Bg)(1)], G.prototype, "type", void 0), y([(0, i.Bg)(2)], G.prototype, "paletteSize", void 0), y([(0, i.Bg)(2)], G.prototype, "rgbKeyFrameCount", void 0), y([(0, i.Bg)(2)], G.prototype, "rgbTrackCount", void 0), y([(0, i.Bg)(2)], G.prototype, "keyFrameCount", void 0), y([(0, i.Bg)(2)], G.prototype, "trackCount", void 0), y([(0, i.Bg)(2)], G.prototype, "animationCount", void 0), y([(0, i.Bg)(2)], G.prototype, "animationSize", void 0), y([(0, i.Bg)(2)], G.prototype, "conditionCount", void 0), y([(0, i.Bg)(2)], G.prototype, "conditionSize", void 0), y([(0, i.Bg)(2)], G.prototype, "actionCount", void 0), y([(0, i.Bg)(2)], G.prototype, "actionSize", void 0), y([(0, i.Bg)(2)], G.prototype, "ruleCount", void 0); class L { constructor() { this.type = g.transferAnimationSetAck, this.result = 0 } } y([(0, i.Bg)(1)], L.prototype, "type", void 0), y([(0, i.Bg)(1)], L.prototype, "result", void 0); class D { constructor() { this.type = g.transferTestAnimationSet, this.paletteSize = 0, this.rgbKeyFrameCount = 0, this.rgbTrackCount = 0, this.keyFrameCount = 0, this.trackCount = 0, this.animationSize = 0, this.hash = 0 } } y([(0, i.Bg)(1)], D.prototype, "type", void 0), y([(0, i.Bg)(2)], D.prototype, "paletteSize", void 0), y([(0, i.Bg)(2)], D.prototype, "rgbKeyFrameCount", void 0), y([(0, i.Bg)(2)], D.prototype, "rgbTrackCount", void 0), y([(0, i.Bg)(2)], D.prototype, "keyFrameCount", void 0), y([(0, i.Bg)(2)], D.prototype, "trackCount", void 0), y([(0, i.Bg)(2)], D.prototype, "animationSize", void 0), y([(0, i.Bg)(4)], D.prototype, "hash", void 0); const I = { download: (0, i.GP)(0), upToDate: (0, i.GP)(), noMemory: (0, i.GP)() }; class j { constructor() { this.type = g.transferTestAnimationSetAck, this.ackType = I.download } } y([(0, i.Bg)(1)], j.prototype, "type", void 0), y([(0, i.Bg)(1)], j.prototype, "ackType", void 0); class z { constructor() { this.type = g.debugLog, this.message = "" } } y([(0, i.Bg)(1)], z.prototype, "type", void 0), y([(0, i.Bg)(d)], z.prototype, "message", void 0); class U { constructor() { this.type = g.remoteAction, this.actionId = 0 } } y([(0, i.Bg)(1)], U.prototype, "type", void 0), y([(0, i.Bg)(2)], U.prototype, "actionId", void 0); const $ = { off: (0, i.GP)(0), once: (0, i.GP)(), automatic: (0, i.GP)() }; class V { constructor() { this.type = g.requestTelemetry, this.requestMode = $.off, this.minInterval = 0 } } y([(0, i.Bg)(1)], V.prototype, "type", void 0), y([(0, i.Bg)(1)], V.prototype, "requestMode", void 0), y([(0, i.Bg)(2)], V.prototype, "minInterval", void 0); class K { constructor() { this.type = g.blink, this.count = 0, this.duration = 0, this.color = 0, this.faceMask = f.Constants.faceMaskAll, this.fade = 0, this.loop = !1 } } y([(0, i.Bg)(1)], K.prototype, "type", void 0), y([(0, i.Bg)(1)], K.prototype, "count", void 0), y([(0, i.Bg)(2)], K.prototype, "duration", void 0), y([(0, i.Bg)(4)], K.prototype, "color", void 0), y([(0, i.Bg)(4)], K.prototype, "faceMask", void 0), y([(0, i.Bg)(1)], K.prototype, "fade", void 0), y([(0, i.Bg)(1)], K.prototype, "loop", void 0); const q = { ok: (0, i.GP)(0), low: (0, i.GP)(), charging: (0, i.GP)(), done: (0, i.GP)(), badCharging: (0, i.GP)(), error: (0, i.GP)() }; class W { constructor() { this.type = g.batteryLevel, this.levelPercent = 0, this.state = q.ok } } y([(0, i.Bg)(1)], W.prototype, "type", void 0), y([(0, i.Bg)(1)], W.prototype, "levelPercent", void 0), y([(0, i.Bg)(1)], W.prototype, "state", void 0); class N { constructor() { this.type = g.requestRssi, this.requestMode = $.off, this.minInterval = 0 } } y([(0, i.Bg)(1)], N.prototype, "type", void 0), y([(0, i.Bg)(1)], N.prototype, "requestMode", void 0), y([(0, i.Bg)(2)], N.prototype, "minInterval", void 0); class H { constructor() { this.type = g.rssi, this.value = 0 } } y([(0, i.Bg)(1)], H.prototype, "type", void 0), y([(0, i.Bg)(1, { numberFormat: "signed" })], H.prototype, "value", void 0); class Y { constructor() { this.type = g.notifyUser, this.timeoutSec = 0, this.ok = !1, this.cancel = !1, this.message = "" } } y([(0, i.Bg)(1)], Y.prototype, "type", void 0), y([(0, i.Bg)(1)], Y.prototype, "timeoutSec", void 0), y([(0, i.Bg)(1)], Y.prototype, "ok", void 0), y([(0, i.Bg)(1)], Y.prototype, "cancel", void 0), y([(0, i.Bg)(d - 4)], Y.prototype, "message", void 0); class Z { constructor() { this.type = g.notifyUserAck, this.okCancel = !1 } } y([(0, i.Bg)(1)], Z.prototype, "type", void 0), y([(0, i.Bg)(1)], Z.prototype, "okCancel", void 0); class X { constructor() { this.type = g.ledLoopback, this.value = 0 } } y([(0, i.Bg)(1)], X.prototype, "type", void 0), y([(0, i.Bg)(1)], X.prototype, "value", void 0); class J { constructor() { this.type = g.setDesignAndColor, this.designAndColor = 0 } } y([(0, i.Bg)(1)], J.prototype, "type", void 0), y([(0, i.Bg)(1)], J.prototype, "designAndColor", void 0); class Q { constructor() { this.type = g.setName, this.name = "" } } y([(0, i.Bg)(1)], Q.prototype, "type", void 0), y([(0, i.Bg)(d)], Q.prototype, "name", void 0); class tt { constructor() { this.type = g.transferInstantAnimationSet, this.paletteSize = 0, this.rgbKeyFrameCount = 0, this.rgbTrackCount = 0, this.keyFrameCount = 0, this.trackCount = 0, this.animationCount = 0, this.animationSize = 0, this.hash = 0 } } y([(0, i.Bg)(1)], tt.prototype, "type", void 0), y([(0, i.Bg)(2)], tt.prototype, "paletteSize", void 0), y([(0, i.Bg)(2)], tt.prototype, "rgbKeyFrameCount", void 0), y([(0, i.Bg)(2)], tt.prototype, "rgbTrackCount", void 0), y([(0, i.Bg)(2)], tt.prototype, "keyFrameCount", void 0), y([(0, i.Bg)(2)], tt.prototype, "trackCount", void 0), y([(0, i.Bg)(2)], tt.prototype, "animationCount", void 0), y([(0, i.Bg)(2)], tt.prototype, "animationSize", void 0), y([(0, i.Bg)(4)], tt.prototype, "hash", void 0); class et { constructor() { this.type = g.transferInstantAnimationSetAck, this.ackType = I.download } } y([(0, i.Bg)(1)], et.prototype, "type", void 0), y([(0, i.Bg)(1)], et.prototype, "ackType", void 0); class nt { constructor() { this.type = g.playInstantAnimation, this.animation = 0, this.faceIndex = 0, this.loop = !1 } } y([(0, i.Bg)(1)], nt.prototype, "type", void 0), y([(0, i.Bg)(1)], nt.prototype, "animation", void 0), y([(0, i.Bg)(1)], nt.prototype, "faceIndex", void 0), y([(0, i.Bg)(1)], nt.prototype, "loop", void 0); class rt { constructor() { this.type = g.temperature, this.mcuTemperatureTimes100 = 0, this.batteryTemperatureTimes100 = 0 } } y([(0, i.Bg)(1)], rt.prototype, "type", void 0), y([(0, i.Bg)(2)], rt.prototype, "mcuTemperatureTimes100", void 0), y([(0, i.Bg)(2)], rt.prototype, "batteryTemperatureTimes100", void 0); class it { constructor() { this.type = g.discharge, this.currentMA = 0 } } y([(0, i.Bg)(1)], it.prototype, "type", void 0), y([(0, i.Bg)(1)], it.prototype, "currentMA", void 0); class ot { constructor() { this.type = g.blinkId, this.brightness = 0, this.loop = !1 } } y([(0, i.Bg)(1)], ot.prototype, "type", void 0), y([(0, i.Bg)(1)], ot.prototype, "brightness", void 0), y([(0, i.Bg)(1)], ot.prototype, "loop", void 0); class st { constructor() { this.type = g.transferTest, this.size = 0 } } function at() { return [T, O, E, R, M, F, G, L, D, j, z, U, K, W, N, H, Y, Z, X, J, Q, tt, et, nt, rt, it, ot, st] } y([(0, i.Bg)(1)], st.prototype, "type", void 0), y([(0, i.Bg)(2, { padding: 1 })], st.prototype, "size", void 0); class ct extends Error { get pixel() { return this._pixel } get cause() { return this._cause } constructor(t, e, n) { super(`Pixel ${t.name}: ${e}`), this.name = "PixelError", this._pixel = t, this._cause = n } } class ut extends ct { constructor(t, e) { const n = e instanceof Error, r = "string" == typeof e ? e : n ? `Connection error. ${e.message}` : `Unsupported connection error, data is ${JSON.stringify(e)}`, i = n ? e : void 0; super(t, `Pixel ${t.name}: ${r}`, i), this.name = "PixelConnectError" } } class lt extends ut { constructor(t, e) { super(t, e), this.name = "PixelConnectTimeoutError" } } class ft extends ut { constructor(t) { super(t, `Connection cancelled (current state is ${t.status})`), this.name = "PixelConnectCancelledError" } } class pt extends ct { constructor(t, e) { super(t, `Pixel identification mismatch: expecting ${t.pixelId.toString(16)} but got ${e.toString(16)}`), this.name = "PixelIdMismatchError" } } class ht extends ct { constructor(t, e) { super(t, e), this.name = "PixelMessageTimeoutError" } } function dt(t) { switch (t) { case q.charging: case q.done: return !0; default: return !1 } } class yt extends u { get logMessages() { return this._logMessages } set logMessages(t) { this._logMessages = t } get logger() { return this._logFunc } set logger(t) { this._logFunc = t } get status() { return this._status } get isReady() { return "ready" === this.status } get systemId() { return this._info.systemId } get pixelId() { return this._info.pixelId } get name() { return this._session.pixelName } get ledCount() { return this._info.ledCount } get designAndColor() { return this._info.designAndColor } get dieType() { return yt.getDieType(this.ledCount) } get dieFaceCount() { return yt.getFaceCount(this.dieType) } get firmwareDate() { return this._info.firmwareDate } get rssi() { return this._info.rssi } get batteryLevel() { return this._info.batteryLevel } get isCharging() { return this._info.isCharging } get rollState() { return this._info.rollState } get currentFace() { return this._info.currentFace } constructor(t, e) { var n, r, o, s, a, c, u, l, f, h; super(), this._evEmitter = (0, i.W2)(), this._msgEvEmitter = new p.EventEmitter, this._logFunc = console.log, this._logMessages = !1, this._info = { systemId: t.pixelSystemId, pixelId: null !== (n = null == e ? void 0 : e.pixelId) && void 0 !== n ? n : 0, name: null !== (r = null == e ? void 0 : e.name) && void 0 !== r ? r : "", ledCount: null !== (o = null == e ? void 0 : e.ledCount) && void 0 !== o ? o : 0, designAndColor: null !== (s = null == e ? void 0 : e.designAndColor) && void 0 !== s ? s : "unknown", firmwareDate: null !== (a = null == e ? void 0 : e.firmwareDate) && void 0 !== a ? a : new Date, rssi: null !== (c = null == e ? void 0 : e.rssi) && void 0 !== c ? c : 0, batteryLevel: null !== (u = null == e ? void 0 : e.batteryLevel) && void 0 !== u ? u : 0, isCharging: null !== (l = null == e ? void 0 : e.isCharging) && void 0 !== l && l, rollState: null !== (f = null == e ? void 0 : e.rollState) && void 0 !== f ? f : "unknown", currentFace: null !== (h = null == e ? void 0 : e.currentFace) && void 0 !== h ? h : 0 }, this._session = t, this._status = "disconnected", t.setConnectionEventListener((({ connectionStatus: t }) => { "connected" !== t && "ready" !== t && this._updateStatus("failedToConnect" === t ? "disconnected" : t) })); const d = t => { var e; const n = t, r = { state: null !== (e = (0, i.ZO)(n.state, x)) && void 0 !== e ? e : "unknown", face: n.faceIndex + 1 }, o = this._info.rollState !== r.state, s = this._info.currentFace !== r.face; o && (this._info.rollState = r.state, this.emitPropertyEvent("rollState")), s && (this._info.currentFace = r.face, this.emitPropertyEvent("currentFace")), this._evEmitter.emit("rollState", Object.assign({}, r)), "onFace" === r.state && this._evEmitter.emit("roll", r.face) }; this.addMessageListener("rollState", d); const y = t => { const e = t, n = { level: e.levelPercent, isCharging: dt(e.state) }, r = this._info.batteryLevel !== n.level, i = this._info.isCharging !== n.isCharging; r && (this._info.batteryLevel = n.level, this.emitPropertyEvent("batteryLevel")), i && (this._info.isCharging = n.isCharging, this.emitPropertyEvent("isCharging")), (r || i) && this._evEmitter.emit("battery", n) }; this.addMessageListener("batteryLevel", y); const g = t => { const e = t; e.value !== this._info.rssi && (this._info.rssi = e.value, this.emitPropertyEvent("rssi"), this._evEmitter.emit("rssi", e.value)) }; this.addMessageListener("rssi", g); const m = t => { const e = t; this._evEmitter.emit("userMessage", { message: e.message, withCancel: e.cancel, response: t => this.sendMessage((0, i.v3)(new Z, { okCancel: t })) }) }; this.addMessageListener("notifyUser", m); const v = t => { const e = t; this._evEmitter.emit("remoteAction", e.actionId) }; this.addMessageListener("remoteAction", v), this._disposeFunc = () => { t.setConnectionEventListener(void 0), this.addMessageListener("rollState", d), this.addMessageListener("batteryLevel", y), this.addMessageListener("rssi", g), this.addMessageListener("notifyUser", m), this.addMessageListener("remoteAction", v) } } _dispose() { this._disposeFunc() } async connect(t = 0) { let e = !1; const n = t > 0 && setTimeout((() => { e = !0, this._session.disconnect().catch((() => { })) }), t); try { if (await this._session.connect(), "connecting" === this.status) { this._updateStatus("identifying"); try { await this._internalSetup(), "identifying" === this.status && (this._updateStatus("ready"), this._evEmitter.emit("battery", { level: this._info.batteryLevel, isCharging: this._info.isCharging })) } catch (t) { try { await this._session.disconnect() } catch (t) { } throw t } } else "identifying" === this.status && await new Promise((t => { const e = n => { "identifying" !== n && (this.removeEventListener("status", e), t()) }; this.addEventListener("status", e) })); if ("ready" !== this.status) throw new ft(this) } catch (n) { throw e ? new lt(this, `Connection timeout after ${t} ms`) : n instanceof ut ? n : new ut(this, n) } finally { n && clearTimeout(n) } return this } async disconnect() { return await this._session.disconnect(), this } addEventListener(t, e) { this._evEmitter.addListener(t, e) } removeEventListener(t, e) { this._evEmitter.removeListener(t, e) } addMessageListener(t, e) { this._msgEvEmitter.addListener(`${t}Message`, e) } removeMessageListener(t, e) { this._msgEvEmitter.removeListener(`${t}Message`, e) } waitForMessage(t, e = h) { return new Promise(((n, r) => { let i; const o = e => { i && (clearTimeout(i), i = void 0, this.removeMessageListener(t, o), n(e)) }; i = setTimeout((() => { i && (i = void 0, this.removeMessageListener(t, o), r(new ht(this, `Timeout of ${e}ms waiting on message ${t}`))) }), e), this.addMessageListener(t, o) })) } async sendMessage(t, e = !1) { if (this._logMessages) { const e = k(t); this._log(`Sending message ${e} (${g[e]})`) } const n = C(t); await this._session.writeValue(n, e), this._evEmitter.emit("messageSend", t) } async sendAndWaitForResponse(t, e, n = h) { return (await Promise.all([this.waitForMessage(e, n), this.sendMessage(t)]))[0] } async sendAndWaitForTypedResponse(t, e, n = h) { return await this.sendAndWaitForResponse(t, k((new e).type), n) } async rename(t) { t.length && await this.sendAndWaitForResponse((0, i.v3)(new Q, { name: t }), "setNameAck") } async startCalibration() { await this.sendMessage("calibrate") } async reportRssi(t, e = 5e3) { await this.sendMessage((0, i.v3)(new N, { requestMode: t ? $.automatic : $.off, minInterval: e })) } async queryRssi() { return (await this.sendAndWaitForResponse((0, i.v3)(new N, { requestMode: $.once }), "rssi")).value } async turnOff() { await this.sendMessage("sleep", !0) } async blink(t, e) { var n, r, o, s, a; const c = (0, i.v3)(new K, { color: f.Color32Utils.toColor32(t), count: null !== (n = null == e ? void 0 : e.count) && void 0 !== n ? n : 1, duration: null !== (r = null == e ? void 0 : e.duration) && void 0 !== r ? r : 1e3, fade: 255 * (null !== (o = null == e ? void 0 : e.fade) && void 0 !== o ? o : 0), faceMask: null !== (s = null == e ? void 0 : e.faceMask) && void 0 !== s ? s : f.Constants.faceMaskAll, loop: null !== (a = null == e ? void 0 : e.loop) && void 0 !== a && a }); await this.sendAndWaitForResponse(c, "blinkAck") } async stopAllAnimations() { await this.sendMessage("stopAllAnimations") } async transferDataSet(t, e) { null == e || e(0); const n = (0, i.v3)(new G, { paletteSize: t.animationBits.getPaletteSize(), rgbKeyFrameCount: t.animationBits.getRgbKeyframeCount(), rgbTrackCount: t.animationBits.getRgbTrackCount(), keyFrameCount: t.animationBits.getKeyframeCount(), trackCount: t.animationBits.getTrackCount(), animationCount: t.animations.length, animationSize: t.animations.reduce(((t, e) => t + (0, i.iR)(e)), 0), conditionCount: t.conditions.length, conditionSize: t.conditions.reduce(((t, e) => t + (0, i.iR)(e)), 0), actionCount: t.actions.length, actionSize: t.actions.reduce(((t, e) => t + (0, i.iR)(e)), 0), ruleCount: t.rules.length }); if (!(await this.sendAndWaitForTypedResponse(n, L)).result) { const e = t.computeDataSetByteSize(); throw new ct(this, `Not enough memory to transfer ${e} bytes`) } { const n = t.toByteArray(); (0, i.hu)(n.length === t.computeDataSetByteSize(), "Incorrect computation of computeDataSetByteSize()"); const r = (f.DataSet.computeHash(n) >>> 0).toString(16).toUpperCase(); this._log(`Ready to receive dataset, byte array should be ${n.length} bytes and hash 0x${r}`), await this.uploadBulkDataWithAck("transferAnimationSetFinished", n, e) } } async playTestAnimation(t, e) { (0, i.hu)(t.animations.length >= 1, "No animation in DataSet"), null == e || e(0); const n = t.toSingleAnimationByteArray(), r = f.DataSet.computeHash(n), o = (0, i.v3)(new D, { paletteSize: t.animationBits.getPaletteSize(), rgbKeyFrameCount: t.animationBits.getRgbKeyframeCount(), rgbTrackCount: t.animationBits.getRgbTrackCount(), keyFrameCount: t.animationBits.getKeyframeCount(), trackCount: t.animationBits.getTrackCount(), animationSize: (0, i.iR)(t.animations[0]), hash: r }), s = await this.sendAndWaitForTypedResponse(o, j); switch (s.ackType) { case I.download: { const t = (r >>> 0).toString(16).toUpperCase(); this._log(`Ready to receive test dataset, byte array should be: ${n.length} bytes and hash 0x${t}`), await this.uploadBulkDataWithAck("transferTestAnimationSetFinished", n, e) } break; case I.upToDate: this._log("Test animation is already up-to-date"); break; default: throw new ct(this, `Got unknown ackType: ${s.ackType}`) } } async transferInstantAnimations(t, e) { (0, i.hu)(t.animations.length >= 1, "No animation in DataSet"), null == e || e(0); const n = t.toAnimationsByteArray(), r = f.DataSet.computeHash(n), o = (0, i.v3)(new tt, { paletteSize: t.animationBits.getPaletteSize(), rgbKeyFrameCount: t.animationBits.getRgbKeyframeCount(), rgbTrackCount: t.animationBits.getRgbTrackCount(), keyFrameCount: t.animationBits.getKeyframeCount(), trackCount: t.animationBits.getTrackCount(), animationCount: t.animations.length, animationSize: t.animations.reduce(((t, e) => t + (0, i.iR)(e)), 0), hash: r }), s = await this.sendAndWaitForTypedResponse(o, et); switch (s.ackType) { case I.download: { const t = (r >>> 0).toString(16).toUpperCase(); this._log(`Ready to receive instant animations, byte array should be: ${n.length} bytes and hash 0x${t}`), await this.uploadBulkDataWithAck("transferInstantAnimationSetFinished", n, e) } break; case I.upToDate: this._log("Instant animations are already up-to-date"); break; default: throw new ct(this, `Got unknown ackType: ${s.ackType}`) } } async playInstantAnimation(t) { await this.sendMessage((0, i.v3)(new nt, { animation: t })) } _log(t) { this._logFunc && ((null == t ? void 0 : t.type) ? this._logFunc(t) : this._logFunc(`[${function () { const t = t => t.toString().padStart(2, "0"), e = new Date; return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + e.getMilliseconds().toString().padStart(3, "0") }()} - Pixel ${this.name}] ${t}`)) } async _internalSetup() { var t, e; let n; await this._session.subscribe((t => this._onValueChanged(t))), this._log("Waiting on identification message"); for (let t = 1; t >= 0; --t)try { n = await this.sendAndWaitForResponse("whoAreYou", "iAmADie", 2e3); break } catch (e) { if (!(t && e instanceof ht)) throw e; this._log("Resending request for identification message") } if ((0, i.hu)(n), this._info.pixelId && this._info.pixelId !== n.pixelId) throw new pt(this, n.pixelId); this._info.ledCount = n.ledCount, this._info.designAndColor = null !== (t = (0, i.ZO)(n.designAndColor, S)) && void 0 !== t ? t : "unknown", this._info.pixelId = n.pixelId; const r = new Date(1e3 * n.buildTimestamp); this._info.firmwareDate.getTime() !== r.getTime() && (this._info.firmwareDate = r, this.emitPropertyEvent("firmwareDate")); const o = n.batteryLevelPercent; this._info.batteryLevel !== o && (this._info.batteryLevel = o, this.emitPropertyEvent("batteryLevel")); const s = dt(n.batteryState); this._info.isCharging !== s && (this._info.isCharging = s, this.emitPropertyEvent("isCharging")); const a = null !== (e = (0, i.ZO)(n.rollState, x)) && void 0 !== e ? e : "unknown"; this._info.rollState !== a && (this._info.rollState = a, this.emitPropertyEvent("rollState")); const c = n.currentFaceIndex + 1; this._info.currentFace !== c && (this._info.currentFace = c, this.emitPropertyEvent("currentFace")) } _updateStatus(t) { this._status !== t && (this._status = t, this._log(`Status changed to ${t}`), this._evEmitter.emit("status", t)) } _onValueChanged(t) { try { const e = P(t.buffer); if (e) { const t = k(e); this._logMessages && (this._log(`Received message ${t} (${g[t]})`), "object" == typeof e && this._log(e)), this._evEmitter.emit("message", e), this._msgEvEmitter.emit(`${t}Message`, e) } else this._log("Received invalid message") } catch (t) { this._log("CharacteristicValueChanged error: " + t) } } async uploadBulkDataWithAck(t, e, n, r = "percent") { let i, o = !1; const s = () => { o = !0, i && (i(), i = void 0) }; this.addMessageListener(t, s); try { await this._uploadBulkData(e, n, r), this._log("Done sending dataset, waiting for Pixel to finish programming"); const t = new Promise(((t, e) => { if (o) t(); else { const n = setTimeout((() => { e(new ct(this, "Timeout waiting on device to confirm programming")) }), h); i = () => { clearTimeout(n), t() } } })); await t, this._log("Programming done") } finally { this.removeMessageListener(t, s) } } async _uploadBulkData(t, e, n = "percent") { let r = t.byteLength; this._log(`Sending ${r} bytes of bulk data`); const i = new R; i.size = r, await this.sendAndWaitForResponse(i, "bulkSetupAck"), this._log("Ready for receiving data"), null == e || e(0); let o = 0, s = 0; const a = new M; for (; r > 0;)if (a.offset = s, a.size = Math.min(r, d), a.data = t.slice(s, s + a.size), await this.sendAndWaitForResponse(a, "bulkDataAck"), r -= a.size, s += a.size, e) { const r = "percent" === n ? Math.round(100 * s / t.byteLength) : s; r > o && (e(r), o = r) } this._log("Finished sending bulk data") } static getDieType(t) { switch (t) { case 4: return "d4"; case 6: return "d6"; case 8: return "d8"; case 10: return "d10"; case 12: return "d12"; case 0: case 20: return "d20"; case 21: return "d6pipped"; default: return "d6fudge" } } static getFaceCount(t) { let e = 2; for (; e < t.length;) { const n = t.charAt(e); if (n < "0" || n > "9") break; ++e } return Number(t.substring(1, e)) } } }, 239: (t, e, n) => { "use strict"; n.d(e, { TH: () => b, EV: () => C, hu: () => i, vE: () => o, yh: () => s, YJ: () => P, iR: () => v, W2: () => c, gw: () => u, vB: () => B, mU: () => h, GP: () => f, ZO: () => A, v3: () => d, Bg: () => g, qC: () => k }); class r extends Error { constructor(t) { super(t), this.name = "AssertionError" } } function i(t, e) { if (!t) throw new r(null != e ? e : "Assert failed") } function o(t, e) { i(!1, null != e ? e : "assertNever error") } function s(t) { let e = 5381; for (let n = 0; n < t.length; ++n)e = 33 * e ^ t[n]; return e } var a = n(699); function c() { return new a.EventEmitter } async function u(t, e) { return new Promise(((n, r) => { if (null == e ? void 0 : e.aborted) r(new Error(`Call to delay(${t}) aborted on start`)); else { const i = () => { clearTimeout(o), r(new Error(`Call to delay(${t}) aborted before timeout`)) }; null == e || e.addEventListener("abort", i); const o = setTimeout((() => { null == e || e.removeEventListener("abort", i), n() }), t) } })) } let l = 0; function f(t) { return void 0 !== t && (l = t), l++ } let p = 0; function h(t) { void 0 !== t && (p = t); const e = 1 << p; return p += 1, e } function d(t, e) { return Object.assign(t, function (t) { return Object.keys(t).forEach((e => void 0 === t[e] && delete t[e])), t }(e)) } n(738); const y = Symbol("pixelAnimationSerializable"); function g(t, e) { return function (n, r) { const i = Reflect.getMetadata(y, n), o = { propertyKey: r, size: t, options: e }; i ? i.push(o) : Reflect.defineMetadata(y, [o], n) } } function m(t) { return Reflect.getMetadata(y, t) } function v(t) { var e; if (Array.isArray(t)) return t.reduce(((t, e) => t + v(e)), 0); { const n = m(t); return null !== (e = null == n ? void 0 : n.reduce(((t, e) => { var n, r; return t + e.size + (null !== (r = null === (n = e.options) || void 0 === n ? void 0 : n.padding) && void 0 !== r ? r : 0) }), 0)) && void 0 !== e ? e : 0 } } class b extends Error { constructor(t) { super(t), this.name = "SerializationError" } } function w(t, e) { const n = m(t); if (!(null == n ? void 0 : n.length)) throw new b("Object has no serializable property"); n.forEach((n => { const r = t[n.propertyKey], i = r instanceof ArrayBuffer || r.buffer && r.buffer instanceof ArrayBuffer; if ("number" != typeof r && "bigint" != typeof r && "boolean" != typeof r && "string" != typeof r && !i) throw new b(`Invalid property type, got ${typeof r} for ${n.propertyKey} but expects number or bigint`); e(n, r) })) } function _(t, e, n = 0) { if (Array.isArray(t)) { const r = { dataView: e, byteOffset: n }; return t.forEach((t => { const [e, n] = k(t, r); r.dataView = e, r.byteOffset = n })), [r.dataView, r.byteOffset] } return w(t, ((t, r) => { var i, o, s, a; let c; if (r instanceof ArrayBuffer ? c = r : r.buffer && r.buffer instanceof ArrayBuffer && (c = r.buffer), c) { const r = new Uint8Array(c), i = Math.min(r.byteLength, t.size); for (let t = 0; t < i; ++t)e.setUint8(n, r[t]), ++n; for (let r = i; r < t.size; ++r)e.setUint8(n, 0), ++n } else { const c = "float" === (null === (i = t.options) || void 0 === i ? void 0 : i.numberFormat), u = "signed" === (null === (o = t.options) || void 0 === o ? void 0 : o.numberFormat); switch (t.size) { case 1: u ? e.setInt8(n, Number(r)) : e.setUint8(n, Number(r)); break; case 2: u ? e.setInt16(n, Number(r), !0) : e.setUint16(n, Number(r), !0); break; case 4: c ? e.setFloat32(n, Number(r), !0) : e.setInt32(n, Number(r), !0); break; case 8: if (!c) throw new b("BigInt not supported"); e.setFloat64(n, Number(r), !0); break; default: throw new b(`Invalid property size, got ${t.size} but expects 1, 2, 4, or 8`) }n += t.size + (null !== (a = null === (s = t.options) || void 0 === s ? void 0 : s.padding) && void 0 !== a ? a : 0) } })), [e, n] } function k(t, e) { var n; if (null == e ? void 0 : e.dataView) return _(t, e.dataView, null !== (n = e.byteOffset) && void 0 !== n ? n : 0); { const [e, n] = _(t, new DataView(new ArrayBuffer(v(t)))); return i(n === e.buffer.byteLength, `Incorrect offset after serialization, got ${n} but was expecting ${e.buffer.byteLength}`), [e, n] } } function B(t, e, n = 0) { return function (t, e, n = 0) { function r(t, e, n, r) { "boolean" != typeof r || "number" != typeof n && "bigint" != typeof n ? i(typeof n == typeof r, `Incorrect value type, got ${typeof n} but was expecting ${typeof r}`) : n = Boolean(n), t[e.propertyKey] = n } return w(t, ((i, o) => { var s, a, c, u; if ("string" == typeof o) { const s = e.buffer.slice(e.byteOffset + n); r(t, i, function (t) { let e = 0, n = ""; for (; e < t.length;) { let r = t[e++]; if (r > 127) if (r > 191 && r < 224) { if (e >= t.length) throw new Error("UTF-8 decode: incomplete 2-byte sequence"); r = (31 & r) << 6 | 63 & t[e++] } else if (r > 223 && r < 240) { if (e + 1 >= t.length) throw new Error("UTF-8 decode: incomplete 3-byte sequence"); r = (15 & r) << 12 | (63 & t[e++]) << 6 | 63 & t[e++] } else { if (!(r > 239 && r < 248)) throw new Error("UTF-8 decode: unknown multibyte start 0x" + r.toString(16) + " at index " + (e - 1)); if (e + 2 >= t.length) throw new Error("UTF-8 decode: incomplete 4-byte sequence"); r = (7 & r) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++] } if (r <= 65535) n += String.fromCharCode(r); else { if (!(r <= 1114111)) throw new Error("UTF-8 decode: code point 0x" + r.toString(16) + " exceeds UTF-16 reach"); r -= 65536, n += String.fromCharCode(r >> 10 | 55296), n += String.fromCharCode(1023 & r | 56320) } } return n }(new Uint8Array(s)), o) } else { const c = "float" === (null === (s = i.options) || void 0 === s ? void 0 : s.numberFormat), u = "signed" === (null === (a = i.options) || void 0 === a ? void 0 : a.numberFormat); let l; switch (i.size) { case 1: l = u ? e.getInt8(n) : e.getUint8(n); break; case 2: l = u ? e.getInt16(n, !0) : e.getUint16(n, !0); break; case 4: l = c ? e.getFloat32(n, !0) : u ? e.getInt32(n, !0) : e.getUint32(n, !0); break; case 8: if (!c) throw new b("BigInt not supported"); l = e.getFloat64(n, !0); break; default: throw new b(`Invalid property size, got ${i.size} but expects 1, 2, 4, or 8`) }r(t, i, l, o) } n += i.size + (null !== (u = null === (c = i.options) || void 0 === c ? void 0 : c.padding) && void 0 !== u ? u : 0) })), [e, n] }(t, e, n) } function C(t) { const e = t % 4; return t + (e ? 4 - e : 0) } function P(t) { const e = []; if (t) { let n = t.toString(2), r = 0; for (; n.length;)"1" === n.at(-1) && e.push(r), n = n.substring(0, n.length - 1), ++r } return e } function A(t, e) { for (const [n, r] of Object.entries(e)) if (r === t) return n } } }, e = {}; function n(r) { var i = e[r]; if (void 0 !== i) return i.exports; var o = e[r] = { exports: {} }; return t[r].call(o.exports, o, o.exports, n), o.exports } return n.d = (t, e) => { for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: e[r] }) }, n.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n(368) })()));